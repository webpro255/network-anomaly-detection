/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: OpenACCOps.td                                                        *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#if defined(GET_OP_CLASSES) || defined(GET_OP_FWD_DEFINES)
#undef GET_OP_FWD_DEFINES
namespace mlir {
namespace acc {
class AtomicCaptureOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class AtomicReadOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class AtomicUpdateOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class AtomicWriteOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class AttachOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class CacheOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class CopyinOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class CopyoutOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class CreateOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DataBoundsOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DataOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DeclareDeviceResidentOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DeclareEnterOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DeclareExitOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DeclareLinkOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DeclareOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DeleteOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DetachOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class DevicePtrOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class EnterDataOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class ExitDataOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class FirstprivateOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class FirstprivateRecipeOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class GetDevicePtrOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class GlobalConstructorOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class GlobalDestructorOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class HostDataOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class InitOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class KernelsOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class LoopOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class NoCreateOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class ParallelOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class PresentOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class PrivateOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class PrivateRecipeOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class ReductionOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class ReductionRecipeOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class RoutineOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class SerialOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class SetOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class ShutdownOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class TerminatorOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class UpdateDeviceOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class UpdateHostOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class UpdateOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class UseDeviceOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class WaitOp;
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {
class YieldOp;
} // namespace acc
} // namespace mlir
#endif

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicCaptureOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicCaptureOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AtomicCaptureOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AtomicCaptureOpGenericAdaptorBase(AtomicCaptureOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class AtomicCaptureOpGenericAdaptor : public detail::AtomicCaptureOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicCaptureOpGenericAdaptorBase;
public:
  AtomicCaptureOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicCaptureOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicCaptureOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AtomicCaptureOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicCaptureOp>>>
  AtomicCaptureOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicCaptureOpAdaptor : public AtomicCaptureOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicCaptureOpGenericAdaptor::AtomicCaptureOpGenericAdaptor;
  AtomicCaptureOpAdaptor(AtomicCaptureOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AtomicCaptureOp : public ::mlir::Op<AtomicCaptureOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::SingleBlockImplicitTerminator<TerminatorOp>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::accomp::AtomicCaptureOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicCaptureOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicCaptureOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.atomic.capture");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
  /// Returns the `atomic.read` operation inside the region, if any.
  /// Otherwise, it returns nullptr.
  AtomicReadOp getAtomicReadOp();

  /// Returns the `atomic.write` operation inside the region, if any.
  /// Otherwise, it returns nullptr.
  AtomicWriteOp getAtomicWriteOp();

  /// Returns the `atomic.update` operation inside the region, if any.
  /// Otherwise, it returns nullptr.
  AtomicUpdateOp getAtomicUpdateOp();
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicCaptureOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicReadOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicReadOpGenericAdaptorBase {
public:
  struct Properties {
    using element_typeTy = ::mlir::TypeAttr;
    element_typeTy element_type;

    auto getElementType() {
      auto &propStorage = this->element_type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setElementType(const ::mlir::TypeAttr &propValue) {
      this->element_type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.element_type == this->element_type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AtomicReadOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  AtomicReadOpGenericAdaptorBase(AtomicReadOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::TypeAttr getElementTypeAttr();
  ::mlir::Type getElementType();
};
} // namespace detail
template <typename RangeT>
class AtomicReadOpGenericAdaptor : public detail::AtomicReadOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicReadOpGenericAdaptorBase;
public:
  AtomicReadOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicReadOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicReadOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = AtomicReadOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicReadOp>>>
  AtomicReadOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  ValueT getV() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicReadOpAdaptor : public AtomicReadOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicReadOpGenericAdaptor::AtomicReadOpGenericAdaptor;
  AtomicReadOpAdaptor(AtomicReadOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AtomicReadOp : public ::mlir::Op<AtomicReadOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::accomp::AtomicReadOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicReadOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicReadOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("element_type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getElementTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getElementTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.atomic.read");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getX();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getV();
  ::mlir::OpOperand &getXMutable();
  ::mlir::OpOperand &getVMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::TypeAttr getElementTypeAttr();
  ::mlir::Type getElementType();
  void setElementTypeAttr(::mlir::TypeAttr attr);
  void setElementType(::mlir::Type attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value v, ::mlir::TypeAttr element_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value v, ::mlir::TypeAttr element_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value v, ::mlir::Type element_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value v, ::mlir::Type element_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicReadOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicUpdateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicUpdateOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AtomicUpdateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AtomicUpdateOpGenericAdaptorBase(AtomicUpdateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class AtomicUpdateOpGenericAdaptor : public detail::AtomicUpdateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicUpdateOpGenericAdaptorBase;
public:
  AtomicUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicUpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicUpdateOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AtomicUpdateOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicUpdateOp>>>
  AtomicUpdateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicUpdateOpAdaptor : public AtomicUpdateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicUpdateOpGenericAdaptor::AtomicUpdateOpGenericAdaptor;
  AtomicUpdateOpAdaptor(AtomicUpdateOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AtomicUpdateOp : public ::mlir::Op<AtomicUpdateOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::SingleBlock, ::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::accomp::AtomicUpdateOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicUpdateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicUpdateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.atomic.update");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getX();
  ::mlir::OpOperand &getXMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  ::mlir::LogicalResult verifyRegions();
  static ::mlir::LogicalResult canonicalize(AtomicUpdateOp op, ::mlir::PatternRewriter &rewriter);
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
  Operation* getFirstOp() {
    return &getRegion().front().getOperations().front();
  }
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicUpdateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicWriteOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AtomicWriteOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AtomicWriteOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AtomicWriteOpGenericAdaptorBase(AtomicWriteOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class AtomicWriteOpGenericAdaptor : public detail::AtomicWriteOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AtomicWriteOpGenericAdaptorBase;
public:
  AtomicWriteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AtomicWriteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AtomicWriteOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AtomicWriteOp, typename = std::enable_if_t<std::is_same_v<LateInst, AtomicWriteOp>>>
  AtomicWriteOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  ValueT getExpr() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AtomicWriteOpAdaptor : public AtomicWriteOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AtomicWriteOpGenericAdaptor::AtomicWriteOpGenericAdaptor;
  AtomicWriteOpAdaptor(AtomicWriteOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AtomicWriteOp : public ::mlir::Op<AtomicWriteOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::accomp::AtomicWriteOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AtomicWriteOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AtomicWriteOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.atomic.write");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getX();
  ::mlir::Value getExpr();
  ::mlir::OpOperand &getXMutable();
  ::mlir::OpOperand &getExprMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value expr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value expr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicWriteOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AttachOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AttachOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AttachOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  AttachOpGenericAdaptorBase(AttachOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class AttachOpGenericAdaptor : public detail::AttachOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AttachOpGenericAdaptorBase;
public:
  AttachOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AttachOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AttachOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = AttachOp, typename = std::enable_if_t<std::is_same_v<LateInst, AttachOp>>>
  AttachOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AttachOpAdaptor : public AttachOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AttachOpGenericAdaptor::AttachOpGenericAdaptor;
  AttachOpAdaptor(AttachOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AttachOp : public ::mlir::Op<AttachOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AttachOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AttachOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.attach");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::AttachOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CacheOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CacheOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CacheOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  CacheOpGenericAdaptorBase(CacheOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class CacheOpGenericAdaptor : public detail::CacheOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CacheOpGenericAdaptorBase;
public:
  CacheOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CacheOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CacheOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = CacheOp, typename = std::enable_if_t<std::is_same_v<LateInst, CacheOp>>>
  CacheOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CacheOpAdaptor : public CacheOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CacheOpGenericAdaptor::CacheOpGenericAdaptor;
  CacheOpAdaptor(CacheOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CacheOp : public ::mlir::Op<CacheOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CacheOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CacheOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.cache");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Check if this is a cache with readonly modifier.
  bool isCacheReadonly() {
    return getDataClause() == acc::DataClause::acc_cache_readonly;
  }
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::CacheOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CopyinOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CopyinOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CopyinOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  CopyinOpGenericAdaptorBase(CopyinOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class CopyinOpGenericAdaptor : public detail::CopyinOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CopyinOpGenericAdaptorBase;
public:
  CopyinOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CopyinOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CopyinOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = CopyinOp, typename = std::enable_if_t<std::is_same_v<LateInst, CopyinOp>>>
  CopyinOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CopyinOpAdaptor : public CopyinOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CopyinOpGenericAdaptor::CopyinOpGenericAdaptor;
  CopyinOpAdaptor(CopyinOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CopyinOp : public ::mlir::Op<CopyinOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CopyinOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CopyinOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.copyin");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Check if this is a copyin with readonly modifier.
  bool isCopyinReadonly();
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::CopyinOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CopyoutOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CopyoutOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CopyoutOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  CopyoutOpGenericAdaptorBase(CopyoutOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class CopyoutOpGenericAdaptor : public detail::CopyoutOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CopyoutOpGenericAdaptorBase;
public:
  CopyoutOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CopyoutOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CopyoutOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = CopyoutOp, typename = std::enable_if_t<std::is_same_v<LateInst, CopyoutOp>>>
  CopyoutOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getAccPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtr() {
    return (*getODSOperands(1).begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CopyoutOpAdaptor : public CopyoutOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CopyoutOpGenericAdaptor::CopyoutOpGenericAdaptor;
  CopyoutOpAdaptor(CopyoutOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CopyoutOp : public ::mlir::Op<CopyoutOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CopyoutOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CopyoutOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.copyout");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getAccPtrMutable();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Check if this is a copyout with zero modifier.
  bool isCopyoutZero();
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::CopyoutOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CreateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CreateOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CreateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  CreateOpGenericAdaptorBase(CreateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class CreateOpGenericAdaptor : public detail::CreateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CreateOpGenericAdaptorBase;
public:
  CreateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CreateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CreateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = CreateOp, typename = std::enable_if_t<std::is_same_v<LateInst, CreateOp>>>
  CreateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CreateOpAdaptor : public CreateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CreateOpGenericAdaptor::CreateOpGenericAdaptor;
  CreateOpAdaptor(CreateOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CreateOp : public ::mlir::Op<CreateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CreateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CreateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.create");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Check if this is a create with zero modifier.
  bool isCreateZero();
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::CreateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DataBoundsOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DataBoundsOpGenericAdaptorBase {
public:
  struct Properties {
    using strideInBytesTy = ::mlir::BoolAttr;
    strideInBytesTy strideInBytes;

    auto getStrideInBytes() {
      auto &propStorage = this->strideInBytes;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStrideInBytes(const ::mlir::BoolAttr &propValue) {
      this->strideInBytes = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 5>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.strideInBytes == this->strideInBytes &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DataBoundsOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DataBoundsOpGenericAdaptorBase(DataBoundsOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::BoolAttr getStrideInBytesAttr();
  bool getStrideInBytes();
};
} // namespace detail
template <typename RangeT>
class DataBoundsOpGenericAdaptor : public detail::DataBoundsOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DataBoundsOpGenericAdaptorBase;
public:
  DataBoundsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DataBoundsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DataBoundsOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DataBoundsOp, typename = std::enable_if_t<std::is_same_v<LateInst, DataBoundsOp>>>
  DataBoundsOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLowerbound() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getUpperbound() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getExtent() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getStride() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getStartIdx() {
    auto operands = getODSOperands(4);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DataBoundsOpAdaptor : public DataBoundsOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DataBoundsOpGenericAdaptor::DataBoundsOpGenericAdaptor;
  DataBoundsOpAdaptor(DataBoundsOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DataBoundsOp : public ::mlir::Op<DataBoundsOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::DataBoundsType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DataBoundsOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DataBoundsOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("strideInBytes"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getStrideInBytesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getStrideInBytesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.bounds");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLowerbound();
  ::mlir::Value getUpperbound();
  ::mlir::Value getExtent();
  ::mlir::Value getStride();
  ::mlir::Value getStartIdx();
  ::mlir::MutableOperandRange getLowerboundMutable();
  ::mlir::MutableOperandRange getUpperboundMutable();
  ::mlir::MutableOperandRange getExtentMutable();
  ::mlir::MutableOperandRange getStrideMutable();
  ::mlir::MutableOperandRange getStartIdxMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::DataBoundsType> getResult();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::BoolAttr getStrideInBytesAttr();
  bool getStrideInBytes();
  void setStrideInBytesAttr(::mlir::BoolAttr attr);
  void setStrideInBytes(bool attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, ::mlir::BoolAttr strideInBytes, /*optional*/::mlir::Value startIdx);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, ::mlir::BoolAttr strideInBytes, /*optional*/::mlir::Value startIdx);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, bool strideInBytes, /*optional*/::mlir::Value startIdx);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, bool strideInBytes, /*optional*/::mlir::Value startIdx);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DataBoundsOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DataOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncOnlyTy = ::mlir::ArrayAttr;
    asyncOnlyTy asyncOnly;

    auto getAsyncOnly() {
      auto &propStorage = this->asyncOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOnly(const ::mlir::ArrayAttr &propValue) {
      this->asyncOnly = propValue;
    }
    using asyncOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    asyncOperandsDeviceTypeTy asyncOperandsDeviceType;

    auto getAsyncOperandsDeviceType() {
      auto &propStorage = this->asyncOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->asyncOperandsDeviceType = propValue;
    }
    using defaultAttrTy = ::mlir::acc::ClauseDefaultValueAttr;
    defaultAttrTy defaultAttr;

    auto getDefaultAttr() {
      auto &propStorage = this->defaultAttr;
      return ::llvm::dyn_cast_or_null<::mlir::acc::ClauseDefaultValueAttr>(propStorage);
    }
    void setDefaultAttr(const ::mlir::acc::ClauseDefaultValueAttr &propValue) {
      this->defaultAttr = propValue;
    }
    using hasWaitDevnumTy = ::mlir::ArrayAttr;
    hasWaitDevnumTy hasWaitDevnum;

    auto getHasWaitDevnum() {
      auto &propStorage = this->hasWaitDevnum;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setHasWaitDevnum(const ::mlir::ArrayAttr &propValue) {
      this->hasWaitDevnum = propValue;
    }
    using waitOnlyTy = ::mlir::ArrayAttr;
    waitOnlyTy waitOnly;

    auto getWaitOnly() {
      auto &propStorage = this->waitOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOnly(const ::mlir::ArrayAttr &propValue) {
      this->waitOnly = propValue;
    }
    using waitOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    waitOperandsDeviceTypeTy waitOperandsDeviceType;

    auto getWaitOperandsDeviceType() {
      auto &propStorage = this->waitOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->waitOperandsDeviceType = propValue;
    }
    using waitOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    waitOperandsSegmentsTy waitOperandsSegments;

    auto getWaitOperandsSegments() {
      auto &propStorage = this->waitOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setWaitOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->waitOperandsSegments = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.asyncOnly == this->asyncOnly &&
        rhs.asyncOperandsDeviceType == this->asyncOperandsDeviceType &&
        rhs.defaultAttr == this->defaultAttr &&
        rhs.hasWaitDevnum == this->hasWaitDevnum &&
        rhs.waitOnly == this->waitOnly &&
        rhs.waitOperandsDeviceType == this->waitOperandsDeviceType &&
        rhs.waitOperandsSegments == this->waitOperandsSegments &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DataOpGenericAdaptorBase(DataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class DataOpGenericAdaptor : public detail::DataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DataOpGenericAdaptorBase;
public:
  DataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DataOp, typename = std::enable_if_t<std::is_same_v<LateInst, DataOp>>>
  DataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getAsyncOperands() {
    return getODSOperands(1);
  }

  RangeT getWaitOperands() {
    return getODSOperands(2);
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DataOpAdaptor : public DataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DataOpGenericAdaptor::DataOpGenericAdaptor;
  DataOpAdaptor(DataOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DataOp : public ::mlir::Op<DataOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("asyncOnly"), ::llvm::StringRef("asyncOperandsDeviceType"), ::llvm::StringRef("defaultAttr"), ::llvm::StringRef("hasWaitDevnum"), ::llvm::StringRef("waitOnly"), ::llvm::StringRef("waitOperandsDeviceType"), ::llvm::StringRef("waitOperandsSegments"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncOnlyAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getDefaultAttrAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getDefaultAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getHasWaitDevnumAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getHasWaitDevnumAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getWaitOnlyAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getWaitOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getWaitOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getWaitOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::Operation::operand_range getAsyncOperands();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getAsyncOperandsMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  void setAsyncOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setAsyncOnlyAttr(::mlir::ArrayAttr attr);
  void setWaitOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setWaitOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setHasWaitDevnumAttr(::mlir::ArrayAttr attr);
  void setWaitOnlyAttr(::mlir::ArrayAttr attr);
  void setDefaultAttrAttr(::mlir::acc::ClauseDefaultValueAttr attr);
  void setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue);
  ::mlir::Attribute removeAsyncOperandsDeviceTypeAttr();
  ::mlir::Attribute removeAsyncOnlyAttr();
  ::mlir::Attribute removeWaitOperandsSegmentsAttr();
  ::mlir::Attribute removeWaitOperandsDeviceTypeAttr();
  ::mlir::Attribute removeHasWaitDevnumAttr();
  ::mlir::Attribute removeWaitOnlyAttr();
  ::mlir::Attribute removeDefaultAttrAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 7 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);

  /// Return true if the op has the async attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasAsyncOnly();
  /// Return true if the op has the async attribute for the given device_type.
  bool hasAsyncOnly(mlir::acc::DeviceType deviceType);
  /// Return the value of the async clause if present.
  mlir::Value getAsyncValue();
  /// Return the value of the async clause for the given device_type if
  /// present.
  mlir::Value getAsyncValue(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the wait attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWaitOnly();
  /// Return true if the op has the wait attribute for the given device_type.
  bool hasWaitOnly(mlir::acc::DeviceType deviceType);
  /// Return the values of the wait clause if present.
  mlir::Operation::operand_range getWaitValues();
  /// Return the values of the wait clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getWaitValues(mlir::acc::DeviceType deviceType);
  /// Return the wait devnum value clause if present;
  mlir::Value getWaitDevnum();
  /// Return the wait devnum value clause for the given device_type if
  /// present.
  mlir::Value getWaitDevnum(mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareDeviceResidentOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeclareDeviceResidentOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DeclareDeviceResidentOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DeclareDeviceResidentOpGenericAdaptorBase(DeclareDeviceResidentOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class DeclareDeviceResidentOpGenericAdaptor : public detail::DeclareDeviceResidentOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeclareDeviceResidentOpGenericAdaptorBase;
public:
  DeclareDeviceResidentOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeclareDeviceResidentOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeclareDeviceResidentOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DeclareDeviceResidentOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeclareDeviceResidentOp>>>
  DeclareDeviceResidentOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeclareDeviceResidentOpAdaptor : public DeclareDeviceResidentOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeclareDeviceResidentOpGenericAdaptor::DeclareDeviceResidentOpGenericAdaptor;
  DeclareDeviceResidentOpAdaptor(DeclareDeviceResidentOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DeclareDeviceResidentOp : public ::mlir::Op<DeclareDeviceResidentOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeclareDeviceResidentOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeclareDeviceResidentOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.declare_device_resident");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareDeviceResidentOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareEnterOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeclareEnterOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DeclareEnterOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DeclareEnterOpGenericAdaptorBase(DeclareEnterOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class DeclareEnterOpGenericAdaptor : public detail::DeclareEnterOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeclareEnterOpGenericAdaptorBase;
public:
  DeclareEnterOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeclareEnterOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeclareEnterOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DeclareEnterOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeclareEnterOp>>>
  DeclareEnterOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeclareEnterOpAdaptor : public DeclareEnterOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeclareEnterOpGenericAdaptor::DeclareEnterOpGenericAdaptor;
  DeclareEnterOpAdaptor(DeclareEnterOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DeclareEnterOp : public ::mlir::Op<DeclareEnterOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::DeclareTokenType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeclareEnterOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeclareEnterOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.declare_enter");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::DeclareTokenType> getToken();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type token, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareEnterOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareExitOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeclareExitOpGenericAdaptorBase {
public:
  struct Properties {
    using operandSegmentSizesTy = std::array<int32_t, 2>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DeclareExitOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DeclareExitOpGenericAdaptorBase(DeclareExitOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class DeclareExitOpGenericAdaptor : public detail::DeclareExitOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeclareExitOpGenericAdaptorBase;
public:
  DeclareExitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeclareExitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeclareExitOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DeclareExitOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeclareExitOp>>>
  DeclareExitOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getToken() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeclareExitOpAdaptor : public DeclareExitOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeclareExitOpGenericAdaptor::DeclareExitOpGenericAdaptor;
  DeclareExitOpAdaptor(DeclareExitOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DeclareExitOp : public ::mlir::Op<DeclareExitOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeclareExitOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeclareExitOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.declare_exit");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getToken();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getTokenMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value token, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value token, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    return {};
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareExitOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareLinkOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeclareLinkOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DeclareLinkOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DeclareLinkOpGenericAdaptorBase(DeclareLinkOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class DeclareLinkOpGenericAdaptor : public detail::DeclareLinkOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeclareLinkOpGenericAdaptorBase;
public:
  DeclareLinkOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeclareLinkOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeclareLinkOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DeclareLinkOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeclareLinkOp>>>
  DeclareLinkOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeclareLinkOpAdaptor : public DeclareLinkOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeclareLinkOpGenericAdaptor::DeclareLinkOpGenericAdaptor;
  DeclareLinkOpAdaptor(DeclareLinkOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DeclareLinkOp : public ::mlir::Op<DeclareLinkOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeclareLinkOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeclareLinkOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.declare_link");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareLinkOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeclareOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DeclareOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DeclareOpGenericAdaptorBase(DeclareOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class DeclareOpGenericAdaptor : public detail::DeclareOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeclareOpGenericAdaptorBase;
public:
  DeclareOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeclareOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeclareOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DeclareOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeclareOp>>>
  DeclareOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeclareOpAdaptor : public DeclareOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeclareOpGenericAdaptor::DeclareOpGenericAdaptor;
  DeclareOpAdaptor(DeclareOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DeclareOp : public ::mlir::Op<DeclareOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeclareOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeclareOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.declare");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeleteOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DeleteOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DeleteOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DeleteOpGenericAdaptorBase(DeleteOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class DeleteOpGenericAdaptor : public detail::DeleteOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DeleteOpGenericAdaptorBase;
public:
  DeleteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DeleteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DeleteOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DeleteOp, typename = std::enable_if_t<std::is_same_v<LateInst, DeleteOp>>>
  DeleteOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getAccPtr() {
    return (*getODSOperands(0).begin());
  }

  RangeT getBounds() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DeleteOpAdaptor : public DeleteOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DeleteOpGenericAdaptor::DeleteOpGenericAdaptor;
  DeleteOpAdaptor(DeleteOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DeleteOp : public ::mlir::Op<DeleteOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DeleteOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DeleteOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.delete");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getAccPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DeleteOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DetachOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DetachOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DetachOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DetachOpGenericAdaptorBase(DetachOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class DetachOpGenericAdaptor : public detail::DetachOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DetachOpGenericAdaptorBase;
public:
  DetachOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DetachOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DetachOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DetachOp, typename = std::enable_if_t<std::is_same_v<LateInst, DetachOp>>>
  DetachOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getAccPtr() {
    return (*getODSOperands(0).begin());
  }

  RangeT getBounds() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DetachOpAdaptor : public DetachOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DetachOpGenericAdaptor::DetachOpGenericAdaptor;
  DetachOpAdaptor(DetachOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DetachOp : public ::mlir::Op<DetachOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DetachOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DetachOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.detach");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getAccPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DetachOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DevicePtrOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DevicePtrOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  DevicePtrOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  DevicePtrOpGenericAdaptorBase(DevicePtrOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class DevicePtrOpGenericAdaptor : public detail::DevicePtrOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DevicePtrOpGenericAdaptorBase;
public:
  DevicePtrOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DevicePtrOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DevicePtrOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = DevicePtrOp, typename = std::enable_if_t<std::is_same_v<LateInst, DevicePtrOp>>>
  DevicePtrOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DevicePtrOpAdaptor : public DevicePtrOpGenericAdaptor<::mlir::ValueRange> {
public:
  using DevicePtrOpGenericAdaptor::DevicePtrOpGenericAdaptor;
  DevicePtrOpAdaptor(DevicePtrOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DevicePtrOp : public ::mlir::Op<DevicePtrOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DevicePtrOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = DevicePtrOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.deviceptr");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::DevicePtrOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::EnterDataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class EnterDataOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncTy = ::mlir::UnitAttr;
    asyncTy async;

    auto getAsync() {
      auto &propStorage = this->async;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setAsync(const ::mlir::UnitAttr &propValue) {
      this->async = propValue;
    }
    using waitTy = ::mlir::UnitAttr;
    waitTy wait;

    auto getWait() {
      auto &propStorage = this->wait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setWait(const ::mlir::UnitAttr &propValue) {
      this->wait = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 5>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.async == this->async &&
        rhs.wait == this->wait &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  EnterDataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  EnterDataOpGenericAdaptorBase(EnterDataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::UnitAttr getAsyncAttr();
  bool getAsync();
  ::mlir::UnitAttr getWaitAttr();
  bool getWait();
};
} // namespace detail
template <typename RangeT>
class EnterDataOpGenericAdaptor : public detail::EnterDataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::EnterDataOpGenericAdaptorBase;
public:
  EnterDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  EnterDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : EnterDataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = EnterDataOp, typename = std::enable_if_t<std::is_same_v<LateInst, EnterDataOp>>>
  EnterDataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getAsyncOperand() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getWaitDevnum() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getWaitOperands() {
    return getODSOperands(3);
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(4);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class EnterDataOpAdaptor : public EnterDataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using EnterDataOpGenericAdaptor::EnterDataOpGenericAdaptor;
  EnterDataOpAdaptor(EnterDataOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class EnterDataOp : public ::mlir::Op<EnterDataOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = EnterDataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = EnterDataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("async"), ::llvm::StringRef("wait"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getWaitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getWaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.enter_data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::Value getAsyncOperand();
  ::mlir::Value getWaitDevnum();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getAsyncOperandMutable();
  ::mlir::MutableOperandRange getWaitDevnumMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getAsyncAttr();
  bool getAsync();
  ::mlir::UnitAttr getWaitAttr();
  bool getWait();
  void setAsyncAttr(::mlir::UnitAttr attr);
  void setAsync(bool attrValue);
  void setWaitAttr(::mlir::UnitAttr attr);
  void setWait(bool attrValue);
  ::mlir::Attribute removeAsyncAttr();
  ::mlir::Attribute removeWaitAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::EnterDataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ExitDataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ExitDataOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncTy = ::mlir::UnitAttr;
    asyncTy async;

    auto getAsync() {
      auto &propStorage = this->async;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setAsync(const ::mlir::UnitAttr &propValue) {
      this->async = propValue;
    }
    using finalizeTy = ::mlir::UnitAttr;
    finalizeTy finalize;

    auto getFinalize() {
      auto &propStorage = this->finalize;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setFinalize(const ::mlir::UnitAttr &propValue) {
      this->finalize = propValue;
    }
    using waitTy = ::mlir::UnitAttr;
    waitTy wait;

    auto getWait() {
      auto &propStorage = this->wait;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setWait(const ::mlir::UnitAttr &propValue) {
      this->wait = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 5>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.async == this->async &&
        rhs.finalize == this->finalize &&
        rhs.wait == this->wait &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ExitDataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  ExitDataOpGenericAdaptorBase(ExitDataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::UnitAttr getAsyncAttr();
  bool getAsync();
  ::mlir::UnitAttr getWaitAttr();
  bool getWait();
  ::mlir::UnitAttr getFinalizeAttr();
  bool getFinalize();
};
} // namespace detail
template <typename RangeT>
class ExitDataOpGenericAdaptor : public detail::ExitDataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ExitDataOpGenericAdaptorBase;
public:
  ExitDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ExitDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ExitDataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = ExitDataOp, typename = std::enable_if_t<std::is_same_v<LateInst, ExitDataOp>>>
  ExitDataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getAsyncOperand() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getWaitDevnum() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getWaitOperands() {
    return getODSOperands(3);
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(4);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ExitDataOpAdaptor : public ExitDataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ExitDataOpGenericAdaptor::ExitDataOpGenericAdaptor;
  ExitDataOpAdaptor(ExitDataOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ExitDataOp : public ::mlir::Op<ExitDataOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ExitDataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ExitDataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("async"), ::llvm::StringRef("finalize"), ::llvm::StringRef("wait"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFinalizeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFinalizeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getWaitAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getWaitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.exit_data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::Value getAsyncOperand();
  ::mlir::Value getWaitDevnum();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getAsyncOperandMutable();
  ::mlir::MutableOperandRange getWaitDevnumMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getAsyncAttr();
  bool getAsync();
  ::mlir::UnitAttr getWaitAttr();
  bool getWait();
  ::mlir::UnitAttr getFinalizeAttr();
  bool getFinalize();
  void setAsyncAttr(::mlir::UnitAttr attr);
  void setAsync(bool attrValue);
  void setWaitAttr(::mlir::UnitAttr attr);
  void setWait(bool attrValue);
  void setFinalizeAttr(::mlir::UnitAttr attr);
  void setFinalize(bool attrValue);
  ::mlir::Attribute removeAsyncAttr();
  ::mlir::Attribute removeWaitAttr();
  ::mlir::Attribute removeFinalizeAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr finalize);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr finalize);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands, /*optional*/bool finalize = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands, /*optional*/bool finalize = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::ExitDataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::FirstprivateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FirstprivateOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  FirstprivateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  FirstprivateOpGenericAdaptorBase(FirstprivateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class FirstprivateOpGenericAdaptor : public detail::FirstprivateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FirstprivateOpGenericAdaptorBase;
public:
  FirstprivateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FirstprivateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FirstprivateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = FirstprivateOp, typename = std::enable_if_t<std::is_same_v<LateInst, FirstprivateOp>>>
  FirstprivateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FirstprivateOpAdaptor : public FirstprivateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using FirstprivateOpGenericAdaptor::FirstprivateOpGenericAdaptor;
  FirstprivateOpAdaptor(FirstprivateOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class FirstprivateOp : public ::mlir::Op<FirstprivateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FirstprivateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = FirstprivateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.firstprivate");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::FirstprivateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::FirstprivateRecipeOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FirstprivateRecipeOpGenericAdaptorBase {
public:
  struct Properties {
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    using typeTy = ::mlir::TypeAttr;
    typeTy type;

    auto getType() {
      auto &propStorage = this->type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setType(const ::mlir::TypeAttr &propValue) {
      this->type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.sym_name == this->sym_name &&
        rhs.type == this->type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  FirstprivateRecipeOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  FirstprivateRecipeOpGenericAdaptorBase(FirstprivateRecipeOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr();
  ::mlir::Type getType();
  ::mlir::Region &getInitRegion();
  ::mlir::Region &getCopyRegion();
  ::mlir::Region &getDestroyRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class FirstprivateRecipeOpGenericAdaptor : public detail::FirstprivateRecipeOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FirstprivateRecipeOpGenericAdaptorBase;
public:
  FirstprivateRecipeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FirstprivateRecipeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FirstprivateRecipeOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = FirstprivateRecipeOp, typename = std::enable_if_t<std::is_same_v<LateInst, FirstprivateRecipeOp>>>
  FirstprivateRecipeOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FirstprivateRecipeOpAdaptor : public FirstprivateRecipeOpGenericAdaptor<::mlir::ValueRange> {
public:
  using FirstprivateRecipeOpGenericAdaptor::FirstprivateRecipeOpGenericAdaptor;
  FirstprivateRecipeOpAdaptor(FirstprivateRecipeOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class FirstprivateRecipeOp : public ::mlir::Op<FirstprivateRecipeOp, ::mlir::OpTrait::NRegions<3>::Impl, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::SymbolOpInterface::Trait, ::mlir::acc::RecipeInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FirstprivateRecipeOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = FirstprivateRecipeOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sym_name"), ::llvm::StringRef("type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.firstprivate.recipe");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getInitRegion();
  ::mlir::Region &getCopyRegion();
  ::mlir::Region &getDestroyRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr();
  ::mlir::Type getType();
  void setSymNameAttr(::mlir::StringAttr attr);
  void setSymName(::llvm::StringRef attrValue);
  void setTypeAttr(::mlir::TypeAttr attr);
  void setType(::mlir::Type attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::FirstprivateRecipeOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::GetDevicePtrOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GetDevicePtrOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GetDevicePtrOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  GetDevicePtrOpGenericAdaptorBase(GetDevicePtrOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class GetDevicePtrOpGenericAdaptor : public detail::GetDevicePtrOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GetDevicePtrOpGenericAdaptorBase;
public:
  GetDevicePtrOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GetDevicePtrOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GetDevicePtrOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = GetDevicePtrOp, typename = std::enable_if_t<std::is_same_v<LateInst, GetDevicePtrOp>>>
  GetDevicePtrOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GetDevicePtrOpAdaptor : public GetDevicePtrOpGenericAdaptor<::mlir::ValueRange> {
public:
  using GetDevicePtrOpGenericAdaptor::GetDevicePtrOpGenericAdaptor;
  GetDevicePtrOpAdaptor(GetDevicePtrOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class GetDevicePtrOp : public ::mlir::Op<GetDevicePtrOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GetDevicePtrOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = GetDevicePtrOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.getdeviceptr");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::GetDevicePtrOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::GlobalConstructorOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GlobalConstructorOpGenericAdaptorBase {
public:
  struct Properties {
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.sym_name == this->sym_name &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GlobalConstructorOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  GlobalConstructorOpGenericAdaptorBase(GlobalConstructorOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class GlobalConstructorOpGenericAdaptor : public detail::GlobalConstructorOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GlobalConstructorOpGenericAdaptorBase;
public:
  GlobalConstructorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GlobalConstructorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GlobalConstructorOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = GlobalConstructorOp, typename = std::enable_if_t<std::is_same_v<LateInst, GlobalConstructorOp>>>
  GlobalConstructorOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GlobalConstructorOpAdaptor : public GlobalConstructorOpGenericAdaptor<::mlir::ValueRange> {
public:
  using GlobalConstructorOpGenericAdaptor::GlobalConstructorOpGenericAdaptor;
  GlobalConstructorOpAdaptor(GlobalConstructorOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class GlobalConstructorOp : public ::mlir::Op<GlobalConstructorOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::SymbolOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GlobalConstructorOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = GlobalConstructorOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sym_name")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.global_ctor");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  void setSymNameAttr(::mlir::StringAttr attr);
  void setSymName(::llvm::StringRef attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::GlobalConstructorOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::GlobalDestructorOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GlobalDestructorOpGenericAdaptorBase {
public:
  struct Properties {
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.sym_name == this->sym_name &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  GlobalDestructorOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  GlobalDestructorOpGenericAdaptorBase(GlobalDestructorOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class GlobalDestructorOpGenericAdaptor : public detail::GlobalDestructorOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GlobalDestructorOpGenericAdaptorBase;
public:
  GlobalDestructorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GlobalDestructorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GlobalDestructorOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = GlobalDestructorOp, typename = std::enable_if_t<std::is_same_v<LateInst, GlobalDestructorOp>>>
  GlobalDestructorOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GlobalDestructorOpAdaptor : public GlobalDestructorOpGenericAdaptor<::mlir::ValueRange> {
public:
  using GlobalDestructorOpGenericAdaptor::GlobalDestructorOpGenericAdaptor;
  GlobalDestructorOpAdaptor(GlobalDestructorOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class GlobalDestructorOp : public ::mlir::Op<GlobalDestructorOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::SymbolOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GlobalDestructorOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = GlobalDestructorOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sym_name")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.global_dtor");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  void setSymNameAttr(::mlir::StringAttr attr);
  void setSymName(::llvm::StringRef attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::GlobalDestructorOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::HostDataOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class HostDataOpGenericAdaptorBase {
public:
  struct Properties {
    using ifPresentTy = ::mlir::UnitAttr;
    ifPresentTy ifPresent;

    auto getIfPresent() {
      auto &propStorage = this->ifPresent;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setIfPresent(const ::mlir::UnitAttr &propValue) {
      this->ifPresent = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 2>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.ifPresent == this->ifPresent &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  HostDataOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  HostDataOpGenericAdaptorBase(HostDataOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::UnitAttr getIfPresentAttr();
  bool getIfPresent();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class HostDataOpGenericAdaptor : public detail::HostDataOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::HostDataOpGenericAdaptorBase;
public:
  HostDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  HostDataOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : HostDataOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = HostDataOp, typename = std::enable_if_t<std::is_same_v<LateInst, HostDataOp>>>
  HostDataOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class HostDataOpAdaptor : public HostDataOpGenericAdaptor<::mlir::ValueRange> {
public:
  using HostDataOpGenericAdaptor::HostDataOpGenericAdaptor;
  HostDataOpAdaptor(HostDataOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class HostDataOp : public ::mlir::Op<HostDataOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = HostDataOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = HostDataOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("ifPresent"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIfPresentAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIfPresentAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.host_data");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getIfPresentAttr();
  bool getIfPresent();
  void setIfPresentAttr(::mlir::UnitAttr attr);
  void setIfPresent(bool attrValue);
  ::mlir::Attribute removeIfPresentAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::HostDataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::InitOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class InitOpGenericAdaptorBase {
public:
  struct Properties {
    using device_typesTy = ::mlir::ArrayAttr;
    device_typesTy device_types;

    auto getDeviceTypes() {
      auto &propStorage = this->device_types;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDeviceTypes(const ::mlir::ArrayAttr &propValue) {
      this->device_types = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 2>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.device_types == this->device_types &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  InitOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  InitOpGenericAdaptorBase(InitOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getDeviceTypesAttr();
  ::std::optional< ::mlir::ArrayAttr > getDeviceTypes();
};
} // namespace detail
template <typename RangeT>
class InitOpGenericAdaptor : public detail::InitOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::InitOpGenericAdaptorBase;
public:
  InitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  InitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : InitOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = InitOp, typename = std::enable_if_t<std::is_same_v<LateInst, InitOp>>>
  InitOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getDeviceNumOperand() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class InitOpAdaptor : public InitOpGenericAdaptor<::mlir::ValueRange> {
public:
  using InitOpGenericAdaptor::InitOpGenericAdaptor;
  InitOpAdaptor(InitOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class InitOp : public ::mlir::Op<InitOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = InitOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = InitOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("device_types"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDeviceTypesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDeviceTypesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.init");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getDeviceNumOperand();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::MutableOperandRange getDeviceNumOperandMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDeviceTypesAttr();
  ::std::optional< ::mlir::ArrayAttr > getDeviceTypes();
  void setDeviceTypesAttr(::mlir::ArrayAttr attr);
  ::mlir::Attribute removeDeviceTypesAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::InitOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::KernelsOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class KernelsOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncOnlyTy = ::mlir::ArrayAttr;
    asyncOnlyTy asyncOnly;

    auto getAsyncOnly() {
      auto &propStorage = this->asyncOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOnly(const ::mlir::ArrayAttr &propValue) {
      this->asyncOnly = propValue;
    }
    using asyncOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    asyncOperandsDeviceTypeTy asyncOperandsDeviceType;

    auto getAsyncOperandsDeviceType() {
      auto &propStorage = this->asyncOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->asyncOperandsDeviceType = propValue;
    }
    using defaultAttrTy = ::mlir::acc::ClauseDefaultValueAttr;
    defaultAttrTy defaultAttr;

    auto getDefaultAttr() {
      auto &propStorage = this->defaultAttr;
      return ::llvm::dyn_cast_or_null<::mlir::acc::ClauseDefaultValueAttr>(propStorage);
    }
    void setDefaultAttr(const ::mlir::acc::ClauseDefaultValueAttr &propValue) {
      this->defaultAttr = propValue;
    }
    using hasWaitDevnumTy = ::mlir::ArrayAttr;
    hasWaitDevnumTy hasWaitDevnum;

    auto getHasWaitDevnum() {
      auto &propStorage = this->hasWaitDevnum;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setHasWaitDevnum(const ::mlir::ArrayAttr &propValue) {
      this->hasWaitDevnum = propValue;
    }
    using numGangsDeviceTypeTy = ::mlir::ArrayAttr;
    numGangsDeviceTypeTy numGangsDeviceType;

    auto getNumGangsDeviceType() {
      auto &propStorage = this->numGangsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setNumGangsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->numGangsDeviceType = propValue;
    }
    using numGangsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    numGangsSegmentsTy numGangsSegments;

    auto getNumGangsSegments() {
      auto &propStorage = this->numGangsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setNumGangsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->numGangsSegments = propValue;
    }
    using numWorkersDeviceTypeTy = ::mlir::ArrayAttr;
    numWorkersDeviceTypeTy numWorkersDeviceType;

    auto getNumWorkersDeviceType() {
      auto &propStorage = this->numWorkersDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setNumWorkersDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->numWorkersDeviceType = propValue;
    }
    using selfAttrTy = ::mlir::UnitAttr;
    selfAttrTy selfAttr;

    auto getSelfAttr() {
      auto &propStorage = this->selfAttr;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setSelfAttr(const ::mlir::UnitAttr &propValue) {
      this->selfAttr = propValue;
    }
    using vectorLengthDeviceTypeTy = ::mlir::ArrayAttr;
    vectorLengthDeviceTypeTy vectorLengthDeviceType;

    auto getVectorLengthDeviceType() {
      auto &propStorage = this->vectorLengthDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setVectorLengthDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->vectorLengthDeviceType = propValue;
    }
    using waitOnlyTy = ::mlir::ArrayAttr;
    waitOnlyTy waitOnly;

    auto getWaitOnly() {
      auto &propStorage = this->waitOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOnly(const ::mlir::ArrayAttr &propValue) {
      this->waitOnly = propValue;
    }
    using waitOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    waitOperandsDeviceTypeTy waitOperandsDeviceType;

    auto getWaitOperandsDeviceType() {
      auto &propStorage = this->waitOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->waitOperandsDeviceType = propValue;
    }
    using waitOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    waitOperandsSegmentsTy waitOperandsSegments;

    auto getWaitOperandsSegments() {
      auto &propStorage = this->waitOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setWaitOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->waitOperandsSegments = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 8>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.asyncOnly == this->asyncOnly &&
        rhs.asyncOperandsDeviceType == this->asyncOperandsDeviceType &&
        rhs.defaultAttr == this->defaultAttr &&
        rhs.hasWaitDevnum == this->hasWaitDevnum &&
        rhs.numGangsDeviceType == this->numGangsDeviceType &&
        rhs.numGangsSegments == this->numGangsSegments &&
        rhs.numWorkersDeviceType == this->numWorkersDeviceType &&
        rhs.selfAttr == this->selfAttr &&
        rhs.vectorLengthDeviceType == this->vectorLengthDeviceType &&
        rhs.waitOnly == this->waitOnly &&
        rhs.waitOperandsDeviceType == this->waitOperandsDeviceType &&
        rhs.waitOperandsSegments == this->waitOperandsSegments &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  KernelsOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  KernelsOpGenericAdaptorBase(KernelsOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::DenseI32ArrayAttr getNumGangsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getNumGangsSegments();
  ::mlir::ArrayAttr getNumGangsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumGangsDeviceType();
  ::mlir::ArrayAttr getNumWorkersDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumWorkersDeviceType();
  ::mlir::ArrayAttr getVectorLengthDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getVectorLengthDeviceType();
  ::mlir::UnitAttr getSelfAttrAttr();
  bool getSelfAttr();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class KernelsOpGenericAdaptor : public detail::KernelsOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::KernelsOpGenericAdaptorBase;
public:
  KernelsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  KernelsOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : KernelsOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = KernelsOp, typename = std::enable_if_t<std::is_same_v<LateInst, KernelsOp>>>
  KernelsOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAsyncOperands() {
    return getODSOperands(0);
  }

  RangeT getWaitOperands() {
    return getODSOperands(1);
  }

  RangeT getNumGangs() {
    return getODSOperands(2);
  }

  RangeT getNumWorkers() {
    return getODSOperands(3);
  }

  RangeT getVectorLength() {
    return getODSOperands(4);
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(5);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getSelfCond() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(7);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class KernelsOpAdaptor : public KernelsOpGenericAdaptor<::mlir::ValueRange> {
public:
  using KernelsOpGenericAdaptor::KernelsOpGenericAdaptor;
  KernelsOpAdaptor(KernelsOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class KernelsOp : public ::mlir::Op<KernelsOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = KernelsOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = KernelsOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("asyncOnly"), ::llvm::StringRef("asyncOperandsDeviceType"), ::llvm::StringRef("defaultAttr"), ::llvm::StringRef("hasWaitDevnum"), ::llvm::StringRef("numGangsDeviceType"), ::llvm::StringRef("numGangsSegments"), ::llvm::StringRef("numWorkersDeviceType"), ::llvm::StringRef("selfAttr"), ::llvm::StringRef("vectorLengthDeviceType"), ::llvm::StringRef("waitOnly"), ::llvm::StringRef("waitOperandsDeviceType"), ::llvm::StringRef("waitOperandsSegments"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncOnlyAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getDefaultAttrAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getDefaultAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getHasWaitDevnumAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getHasWaitDevnumAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getNumGangsDeviceTypeAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getNumGangsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getNumGangsSegmentsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getNumGangsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getNumWorkersDeviceTypeAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getNumWorkersDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getSelfAttrAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getSelfAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getVectorLengthDeviceTypeAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getVectorLengthDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getWaitOnlyAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getWaitOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getWaitOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getWaitOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.kernels");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getAsyncOperands();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Operation::operand_range getNumGangs();
  ::mlir::Operation::operand_range getNumWorkers();
  ::mlir::Operation::operand_range getVectorLength();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::TypedValue<::mlir::IntegerType> getSelfCond();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getAsyncOperandsMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getNumGangsMutable();
  ::mlir::MutableOperandRange getNumWorkersMutable();
  ::mlir::MutableOperandRange getVectorLengthMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getSelfCondMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::DenseI32ArrayAttr getNumGangsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getNumGangsSegments();
  ::mlir::ArrayAttr getNumGangsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumGangsDeviceType();
  ::mlir::ArrayAttr getNumWorkersDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumWorkersDeviceType();
  ::mlir::ArrayAttr getVectorLengthDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getVectorLengthDeviceType();
  ::mlir::UnitAttr getSelfAttrAttr();
  bool getSelfAttr();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  void setAsyncOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setAsyncOnlyAttr(::mlir::ArrayAttr attr);
  void setWaitOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setWaitOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setHasWaitDevnumAttr(::mlir::ArrayAttr attr);
  void setWaitOnlyAttr(::mlir::ArrayAttr attr);
  void setNumGangsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setNumGangsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setNumGangsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setNumWorkersDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setVectorLengthDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setSelfAttrAttr(::mlir::UnitAttr attr);
  void setSelfAttr(bool attrValue);
  void setDefaultAttrAttr(::mlir::acc::ClauseDefaultValueAttr attr);
  void setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue);
  ::mlir::Attribute removeAsyncOperandsDeviceTypeAttr();
  ::mlir::Attribute removeAsyncOnlyAttr();
  ::mlir::Attribute removeWaitOperandsSegmentsAttr();
  ::mlir::Attribute removeWaitOperandsDeviceTypeAttr();
  ::mlir::Attribute removeHasWaitDevnumAttr();
  ::mlir::Attribute removeWaitOnlyAttr();
  ::mlir::Attribute removeNumGangsSegmentsAttr();
  ::mlir::Attribute removeNumGangsDeviceTypeAttr();
  ::mlir::Attribute removeNumWorkersDeviceTypeAttr();
  ::mlir::Attribute removeVectorLengthDeviceTypeAttr();
  ::mlir::Attribute removeSelfAttrAttr();
  ::mlir::Attribute removeDefaultAttrAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 12 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);

  /// Return true if the op has the async attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasAsyncOnly();
  /// Return true if the op has the async attribute for the given device_type.
  bool hasAsyncOnly(mlir::acc::DeviceType deviceType);
  /// Return the value of the async clause if present.
  mlir::Value getAsyncValue();
  /// Return the value of the async clause for the given device_type if
  /// present.
  mlir::Value getAsyncValue(mlir::acc::DeviceType deviceType);

  /// Return the value of the num_workers clause if present.
  mlir::Value getNumWorkersValue();
  /// Return the value of the num_workers clause for the given device_type if
  /// present.
  mlir::Value getNumWorkersValue(mlir::acc::DeviceType deviceType);

  /// Return the value of the vector_length clause if present.
  mlir::Value getVectorLengthValue();
  /// Return the value of the vector_length clause for the given device_type 
  /// if present.
  mlir::Value getVectorLengthValue(mlir::acc::DeviceType deviceType);

  /// Return the values of the num_gangs clause if present.
  mlir::Operation::operand_range getNumGangsValues();
  /// Return the values of the num_gangs clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getNumGangsValues(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the wait attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWaitOnly();
  /// Return true if the op has the wait attribute for the given device_type.
  bool hasWaitOnly(mlir::acc::DeviceType deviceType);
  /// Return the values of the wait clause if present.
  mlir::Operation::operand_range getWaitValues();
  /// Return the values of the wait clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getWaitValues(mlir::acc::DeviceType deviceType);
  /// Return the wait devnum value clause if present;
  mlir::Value getWaitDevnum();
  /// Return the wait devnum value clause for the given device_type if
  /// present.
  mlir::Value getWaitDevnum(mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::KernelsOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::LoopOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class LoopOpGenericAdaptorBase {
public:
  struct Properties {
    using auto_Ty = ::mlir::ArrayAttr;
    auto_Ty auto_;

    auto getAuto_() {
      auto &propStorage = this->auto_;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAuto_(const ::mlir::ArrayAttr &propValue) {
      this->auto_ = propValue;
    }
    using collapseTy = ::mlir::ArrayAttr;
    collapseTy collapse;

    auto getCollapse() {
      auto &propStorage = this->collapse;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setCollapse(const ::mlir::ArrayAttr &propValue) {
      this->collapse = propValue;
    }
    using collapseDeviceTypeTy = ::mlir::ArrayAttr;
    collapseDeviceTypeTy collapseDeviceType;

    auto getCollapseDeviceType() {
      auto &propStorage = this->collapseDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setCollapseDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->collapseDeviceType = propValue;
    }
    using gangTy = ::mlir::ArrayAttr;
    gangTy gang;

    auto getGang() {
      auto &propStorage = this->gang;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setGang(const ::mlir::ArrayAttr &propValue) {
      this->gang = propValue;
    }
    using gangOperandsArgTypeTy = ::mlir::ArrayAttr;
    gangOperandsArgTypeTy gangOperandsArgType;

    auto getGangOperandsArgType() {
      auto &propStorage = this->gangOperandsArgType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setGangOperandsArgType(const ::mlir::ArrayAttr &propValue) {
      this->gangOperandsArgType = propValue;
    }
    using gangOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    gangOperandsDeviceTypeTy gangOperandsDeviceType;

    auto getGangOperandsDeviceType() {
      auto &propStorage = this->gangOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setGangOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->gangOperandsDeviceType = propValue;
    }
    using gangOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    gangOperandsSegmentsTy gangOperandsSegments;

    auto getGangOperandsSegments() {
      auto &propStorage = this->gangOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setGangOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->gangOperandsSegments = propValue;
    }
    using inclusiveUpperboundTy = ::mlir::DenseBoolArrayAttr;
    inclusiveUpperboundTy inclusiveUpperbound;

    auto getInclusiveUpperbound() {
      auto &propStorage = this->inclusiveUpperbound;
      return ::llvm::dyn_cast_or_null<::mlir::DenseBoolArrayAttr>(propStorage);
    }
    void setInclusiveUpperbound(const ::mlir::DenseBoolArrayAttr &propValue) {
      this->inclusiveUpperbound = propValue;
    }
    using independentTy = ::mlir::ArrayAttr;
    independentTy independent;

    auto getIndependent() {
      auto &propStorage = this->independent;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setIndependent(const ::mlir::ArrayAttr &propValue) {
      this->independent = propValue;
    }
    using privatizationsTy = ::mlir::ArrayAttr;
    privatizationsTy privatizations;

    auto getPrivatizations() {
      auto &propStorage = this->privatizations;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivatizations(const ::mlir::ArrayAttr &propValue) {
      this->privatizations = propValue;
    }
    using reductionRecipesTy = ::mlir::ArrayAttr;
    reductionRecipesTy reductionRecipes;

    auto getReductionRecipes() {
      auto &propStorage = this->reductionRecipes;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionRecipes(const ::mlir::ArrayAttr &propValue) {
      this->reductionRecipes = propValue;
    }
    using seqTy = ::mlir::ArrayAttr;
    seqTy seq;

    auto getSeq() {
      auto &propStorage = this->seq;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setSeq(const ::mlir::ArrayAttr &propValue) {
      this->seq = propValue;
    }
    using tileOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    tileOperandsDeviceTypeTy tileOperandsDeviceType;

    auto getTileOperandsDeviceType() {
      auto &propStorage = this->tileOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setTileOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->tileOperandsDeviceType = propValue;
    }
    using tileOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    tileOperandsSegmentsTy tileOperandsSegments;

    auto getTileOperandsSegments() {
      auto &propStorage = this->tileOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setTileOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->tileOperandsSegments = propValue;
    }
    using vectorTy = ::mlir::ArrayAttr;
    vectorTy vector;

    auto getVector() {
      auto &propStorage = this->vector;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setVector(const ::mlir::ArrayAttr &propValue) {
      this->vector = propValue;
    }
    using vectorOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    vectorOperandsDeviceTypeTy vectorOperandsDeviceType;

    auto getVectorOperandsDeviceType() {
      auto &propStorage = this->vectorOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setVectorOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->vectorOperandsDeviceType = propValue;
    }
    using workerTy = ::mlir::ArrayAttr;
    workerTy worker;

    auto getWorker() {
      auto &propStorage = this->worker;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWorker(const ::mlir::ArrayAttr &propValue) {
      this->worker = propValue;
    }
    using workerNumOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    workerNumOperandsDeviceTypeTy workerNumOperandsDeviceType;

    auto getWorkerNumOperandsDeviceType() {
      auto &propStorage = this->workerNumOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWorkerNumOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->workerNumOperandsDeviceType = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 10>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.auto_ == this->auto_ &&
        rhs.collapse == this->collapse &&
        rhs.collapseDeviceType == this->collapseDeviceType &&
        rhs.gang == this->gang &&
        rhs.gangOperandsArgType == this->gangOperandsArgType &&
        rhs.gangOperandsDeviceType == this->gangOperandsDeviceType &&
        rhs.gangOperandsSegments == this->gangOperandsSegments &&
        rhs.inclusiveUpperbound == this->inclusiveUpperbound &&
        rhs.independent == this->independent &&
        rhs.privatizations == this->privatizations &&
        rhs.reductionRecipes == this->reductionRecipes &&
        rhs.seq == this->seq &&
        rhs.tileOperandsDeviceType == this->tileOperandsDeviceType &&
        rhs.tileOperandsSegments == this->tileOperandsSegments &&
        rhs.vector == this->vector &&
        rhs.vectorOperandsDeviceType == this->vectorOperandsDeviceType &&
        rhs.worker == this->worker &&
        rhs.workerNumOperandsDeviceType == this->workerNumOperandsDeviceType &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  LoopOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  LoopOpGenericAdaptorBase(LoopOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::DenseBoolArrayAttr getInclusiveUpperboundAttr();
  ::std::optional<::llvm::ArrayRef<bool>> getInclusiveUpperbound();
  ::mlir::ArrayAttr getCollapseAttr();
  ::std::optional< ::mlir::ArrayAttr > getCollapse();
  ::mlir::ArrayAttr getCollapseDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getCollapseDeviceType();
  ::mlir::ArrayAttr getGangOperandsArgTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangOperandsArgType();
  ::mlir::DenseI32ArrayAttr getGangOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getGangOperandsSegments();
  ::mlir::ArrayAttr getGangOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangOperandsDeviceType();
  ::mlir::ArrayAttr getWorkerNumOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWorkerNumOperandsDeviceType();
  ::mlir::ArrayAttr getVectorOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getVectorOperandsDeviceType();
  ::mlir::ArrayAttr getSeqAttr();
  ::std::optional< ::mlir::ArrayAttr > getSeq();
  ::mlir::ArrayAttr getIndependentAttr();
  ::std::optional< ::mlir::ArrayAttr > getIndependent();
  ::mlir::ArrayAttr getAuto_Attr();
  ::std::optional< ::mlir::ArrayAttr > getAuto_();
  ::mlir::ArrayAttr getGangAttr();
  ::std::optional< ::mlir::ArrayAttr > getGang();
  ::mlir::ArrayAttr getWorkerAttr();
  ::std::optional< ::mlir::ArrayAttr > getWorker();
  ::mlir::ArrayAttr getVectorAttr();
  ::std::optional< ::mlir::ArrayAttr > getVector();
  ::mlir::DenseI32ArrayAttr getTileOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getTileOperandsSegments();
  ::mlir::ArrayAttr getTileOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getTileOperandsDeviceType();
  ::mlir::ArrayAttr getPrivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getPrivatizations();
  ::mlir::ArrayAttr getReductionRecipesAttr();
  ::std::optional< ::mlir::ArrayAttr > getReductionRecipes();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class LoopOpGenericAdaptor : public detail::LoopOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::LoopOpGenericAdaptorBase;
public:
  LoopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  LoopOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : LoopOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = LoopOp, typename = std::enable_if_t<std::is_same_v<LateInst, LoopOp>>>
  LoopOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getLowerbound() {
    return getODSOperands(0);
  }

  RangeT getUpperbound() {
    return getODSOperands(1);
  }

  RangeT getStep() {
    return getODSOperands(2);
  }

  RangeT getGangOperands() {
    return getODSOperands(3);
  }

  RangeT getWorkerNumOperands() {
    return getODSOperands(4);
  }

  RangeT getVectorOperands() {
    return getODSOperands(5);
  }

  RangeT getTileOperands() {
    return getODSOperands(6);
  }

  RangeT getCacheOperands() {
    return getODSOperands(7);
  }

  RangeT getPrivateOperands() {
    return getODSOperands(8);
  }

  RangeT getReductionOperands() {
    return getODSOperands(9);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class LoopOpAdaptor : public LoopOpGenericAdaptor<::mlir::ValueRange> {
public:
  using LoopOpGenericAdaptor::LoopOpGenericAdaptor;
  LoopOpAdaptor(LoopOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class LoopOp : public ::mlir::Op<LoopOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::LoopLikeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = LoopOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = LoopOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("auto_"), ::llvm::StringRef("collapse"), ::llvm::StringRef("collapseDeviceType"), ::llvm::StringRef("gang"), ::llvm::StringRef("gangOperandsArgType"), ::llvm::StringRef("gangOperandsDeviceType"), ::llvm::StringRef("gangOperandsSegments"), ::llvm::StringRef("inclusiveUpperbound"), ::llvm::StringRef("independent"), ::llvm::StringRef("privatizations"), ::llvm::StringRef("reductionRecipes"), ::llvm::StringRef("seq"), ::llvm::StringRef("tileOperandsDeviceType"), ::llvm::StringRef("tileOperandsSegments"), ::llvm::StringRef("vector"), ::llvm::StringRef("vectorOperandsDeviceType"), ::llvm::StringRef("worker"), ::llvm::StringRef("workerNumOperandsDeviceType"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAuto_AttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAuto_AttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getCollapseAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getCollapseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getCollapseDeviceTypeAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getCollapseDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getGangAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getGangAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getGangOperandsArgTypeAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getGangOperandsArgTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getGangOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getGangOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getGangOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getGangOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getInclusiveUpperboundAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getInclusiveUpperboundAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getIndependentAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getIndependentAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getPrivatizationsAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getPrivatizationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getReductionRecipesAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getReductionRecipesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getSeqAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getSeqAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getTileOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getTileOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getTileOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getTileOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getVectorAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getVectorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getVectorOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getVectorOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  ::mlir::StringAttr getWorkerAttrName() {
    return getAttributeNameForIndex(16);
  }

  static ::mlir::StringAttr getWorkerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 16);
  }

  ::mlir::StringAttr getWorkerNumOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(17);
  }

  static ::mlir::StringAttr getWorkerNumOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 17);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.loop");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getLowerbound();
  ::mlir::Operation::operand_range getUpperbound();
  ::mlir::Operation::operand_range getStep();
  ::mlir::Operation::operand_range getGangOperands();
  ::mlir::Operation::operand_range getWorkerNumOperands();
  ::mlir::Operation::operand_range getVectorOperands();
  ::mlir::Operation::operand_range getTileOperands();
  ::mlir::Operation::operand_range getCacheOperands();
  ::mlir::Operation::operand_range getPrivateOperands();
  ::mlir::Operation::operand_range getReductionOperands();
  ::mlir::MutableOperandRange getLowerboundMutable();
  ::mlir::MutableOperandRange getUpperboundMutable();
  ::mlir::MutableOperandRange getStepMutable();
  ::mlir::MutableOperandRange getGangOperandsMutable();
  ::mlir::MutableOperandRange getWorkerNumOperandsMutable();
  ::mlir::MutableOperandRange getVectorOperandsMutable();
  ::mlir::MutableOperandRange getTileOperandsMutable();
  ::mlir::MutableOperandRange getCacheOperandsMutable();
  ::mlir::MutableOperandRange getPrivateOperandsMutable();
  ::mlir::MutableOperandRange getReductionOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseBoolArrayAttr getInclusiveUpperboundAttr();
  ::std::optional<::llvm::ArrayRef<bool>> getInclusiveUpperbound();
  ::mlir::ArrayAttr getCollapseAttr();
  ::std::optional< ::mlir::ArrayAttr > getCollapse();
  ::mlir::ArrayAttr getCollapseDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getCollapseDeviceType();
  ::mlir::ArrayAttr getGangOperandsArgTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangOperandsArgType();
  ::mlir::DenseI32ArrayAttr getGangOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getGangOperandsSegments();
  ::mlir::ArrayAttr getGangOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangOperandsDeviceType();
  ::mlir::ArrayAttr getWorkerNumOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWorkerNumOperandsDeviceType();
  ::mlir::ArrayAttr getVectorOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getVectorOperandsDeviceType();
  ::mlir::ArrayAttr getSeqAttr();
  ::std::optional< ::mlir::ArrayAttr > getSeq();
  ::mlir::ArrayAttr getIndependentAttr();
  ::std::optional< ::mlir::ArrayAttr > getIndependent();
  ::mlir::ArrayAttr getAuto_Attr();
  ::std::optional< ::mlir::ArrayAttr > getAuto_();
  ::mlir::ArrayAttr getGangAttr();
  ::std::optional< ::mlir::ArrayAttr > getGang();
  ::mlir::ArrayAttr getWorkerAttr();
  ::std::optional< ::mlir::ArrayAttr > getWorker();
  ::mlir::ArrayAttr getVectorAttr();
  ::std::optional< ::mlir::ArrayAttr > getVector();
  ::mlir::DenseI32ArrayAttr getTileOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getTileOperandsSegments();
  ::mlir::ArrayAttr getTileOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getTileOperandsDeviceType();
  ::mlir::ArrayAttr getPrivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getPrivatizations();
  ::mlir::ArrayAttr getReductionRecipesAttr();
  ::std::optional< ::mlir::ArrayAttr > getReductionRecipes();
  void setInclusiveUpperboundAttr(::mlir::DenseBoolArrayAttr attr);
  void setInclusiveUpperbound(::std::optional<::llvm::ArrayRef<bool>> attrValue);
  void setCollapseAttr(::mlir::ArrayAttr attr);
  void setCollapseDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setGangOperandsArgTypeAttr(::mlir::ArrayAttr attr);
  void setGangOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setGangOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setGangOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setWorkerNumOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setVectorOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setSeqAttr(::mlir::ArrayAttr attr);
  void setIndependentAttr(::mlir::ArrayAttr attr);
  void setAuto_Attr(::mlir::ArrayAttr attr);
  void setGangAttr(::mlir::ArrayAttr attr);
  void setWorkerAttr(::mlir::ArrayAttr attr);
  void setVectorAttr(::mlir::ArrayAttr attr);
  void setTileOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setTileOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setTileOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setPrivatizationsAttr(::mlir::ArrayAttr attr);
  void setReductionRecipesAttr(::mlir::ArrayAttr attr);
  ::mlir::Attribute removeInclusiveUpperboundAttr();
  ::mlir::Attribute removeCollapseAttr();
  ::mlir::Attribute removeCollapseDeviceTypeAttr();
  ::mlir::Attribute removeGangOperandsArgTypeAttr();
  ::mlir::Attribute removeGangOperandsSegmentsAttr();
  ::mlir::Attribute removeGangOperandsDeviceTypeAttr();
  ::mlir::Attribute removeWorkerNumOperandsDeviceTypeAttr();
  ::mlir::Attribute removeVectorOperandsDeviceTypeAttr();
  ::mlir::Attribute removeSeqAttr();
  ::mlir::Attribute removeIndependentAttr();
  ::mlir::Attribute removeAuto_Attr();
  ::mlir::Attribute removeGangAttr();
  ::mlir::Attribute removeWorkerAttr();
  ::mlir::Attribute removeVectorAttr();
  ::mlir::Attribute removeTileOperandsSegmentsAttr();
  ::mlir::Attribute removeTileOperandsDeviceTypeAttr();
  ::mlir::Attribute removePrivatizationsAttr();
  ::mlir::Attribute removeReductionRecipesAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange lowerbound, ::mlir::ValueRange upperbound, ::mlir::ValueRange step, /*optional*/::mlir::DenseBoolArrayAttr inclusiveUpperbound, /*optional*/::mlir::ArrayAttr collapse, /*optional*/::mlir::ArrayAttr collapseDeviceType, ::mlir::ValueRange gangOperands, /*optional*/::mlir::ArrayAttr gangOperandsArgType, /*optional*/::mlir::DenseI32ArrayAttr gangOperandsSegments, /*optional*/::mlir::ArrayAttr gangOperandsDeviceType, ::mlir::ValueRange workerNumOperands, /*optional*/::mlir::ArrayAttr workerNumOperandsDeviceType, ::mlir::ValueRange vectorOperands, /*optional*/::mlir::ArrayAttr vectorOperandsDeviceType, /*optional*/::mlir::ArrayAttr seq, /*optional*/::mlir::ArrayAttr independent, /*optional*/::mlir::ArrayAttr auto_, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, ::mlir::ValueRange tileOperands, /*optional*/::mlir::DenseI32ArrayAttr tileOperandsSegments, /*optional*/::mlir::ArrayAttr tileOperandsDeviceType, ::mlir::ValueRange cacheOperands, ::mlir::ValueRange privateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  ::llvm::SmallVector<::mlir::Region *> getLoopRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 18 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  static StringRef getAutoAttrStrName() { return "auto"; }
  static StringRef getGangNumKeyword() { return "num"; }
  static StringRef getGangDimKeyword() { return "dim"; }
  static StringRef getGangStaticKeyword() { return "static"; }
  static StringRef getControlKeyword() { return "control"; }

  /// The number of private and reduction operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);

  Block &getBody() { return getLoopRegions().front()->front(); }

  /// Return true if the op has the auto attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasAuto();
  /// Return true if the op has the auto attribute for the given device_type.
  bool hasAuto(mlir::acc::DeviceType deviceType);
  /// Return true if the op has the independent attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasIndependent();
  /// Return true if the op has the independent attribute for the given
  /// device_type.
  bool hasIndependent(mlir::acc::DeviceType deviceType);
  /// Return true if the op has the seq attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasSeq();
  /// Return true if the op has the seq attribute for the given device_type.
  bool hasSeq(mlir::acc::DeviceType deviceType);

  /// Return the value of the vector clause if present.
  mlir::Value getVectorValue();
  /// Return the value of the vector clause for the given device_type 
  /// if present.
  mlir::Value getVectorValue(mlir::acc::DeviceType deviceType);
  /// Return true if the op has the vector attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasVector();
  /// Return true if the op has the vector attribute for the given
  /// device_type.
  bool hasVector(mlir::acc::DeviceType deviceType);

  /// Return the value of the worker clause if present.
  mlir::Value getWorkerValue();
  /// Return the value of the worker clause for the given device_type 
  /// if present.
  mlir::Value getWorkerValue(mlir::acc::DeviceType deviceType);
  /// Return true if the op has the worker attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWorker();
  /// Return true if the op has the worker attribute for the given
  /// device_type.
  bool hasWorker(mlir::acc::DeviceType deviceType);

  /// Return the values of the tile clause if present.
  mlir::Operation::operand_range getTileValues();
  /// Return the values of the tile clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getTileValues(mlir::acc::DeviceType deviceType);

  /// Return the value of the collapse clause if present.
  std::optional<int64_t> getCollapseValue();
  /// Return the value of the collapse clause for the given device_type 
  /// if present.
  std::optional<int64_t> getCollapseValue(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the gang attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasGang();
  /// Return true if the op has the gang attribute for the given
  /// device_type.
  bool hasGang(mlir::acc::DeviceType deviceType);

  /// Return the value of the worker clause if present.
  mlir::Value getGangValue(mlir::acc::GangArgType gangArgType);
  /// Return the value of the worker clause for the given device_type 
  /// if present.
  mlir::Value getGangValue(mlir::acc::GangArgType gangArgType, mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::LoopOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::NoCreateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class NoCreateOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  NoCreateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  NoCreateOpGenericAdaptorBase(NoCreateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class NoCreateOpGenericAdaptor : public detail::NoCreateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::NoCreateOpGenericAdaptorBase;
public:
  NoCreateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  NoCreateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : NoCreateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = NoCreateOp, typename = std::enable_if_t<std::is_same_v<LateInst, NoCreateOp>>>
  NoCreateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class NoCreateOpAdaptor : public NoCreateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using NoCreateOpGenericAdaptor::NoCreateOpGenericAdaptor;
  NoCreateOpAdaptor(NoCreateOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class NoCreateOp : public ::mlir::Op<NoCreateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NoCreateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = NoCreateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.nocreate");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::NoCreateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ParallelOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ParallelOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncOnlyTy = ::mlir::ArrayAttr;
    asyncOnlyTy asyncOnly;

    auto getAsyncOnly() {
      auto &propStorage = this->asyncOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOnly(const ::mlir::ArrayAttr &propValue) {
      this->asyncOnly = propValue;
    }
    using asyncOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    asyncOperandsDeviceTypeTy asyncOperandsDeviceType;

    auto getAsyncOperandsDeviceType() {
      auto &propStorage = this->asyncOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->asyncOperandsDeviceType = propValue;
    }
    using defaultAttrTy = ::mlir::acc::ClauseDefaultValueAttr;
    defaultAttrTy defaultAttr;

    auto getDefaultAttr() {
      auto &propStorage = this->defaultAttr;
      return ::llvm::dyn_cast_or_null<::mlir::acc::ClauseDefaultValueAttr>(propStorage);
    }
    void setDefaultAttr(const ::mlir::acc::ClauseDefaultValueAttr &propValue) {
      this->defaultAttr = propValue;
    }
    using firstprivatizationsTy = ::mlir::ArrayAttr;
    firstprivatizationsTy firstprivatizations;

    auto getFirstprivatizations() {
      auto &propStorage = this->firstprivatizations;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setFirstprivatizations(const ::mlir::ArrayAttr &propValue) {
      this->firstprivatizations = propValue;
    }
    using hasWaitDevnumTy = ::mlir::ArrayAttr;
    hasWaitDevnumTy hasWaitDevnum;

    auto getHasWaitDevnum() {
      auto &propStorage = this->hasWaitDevnum;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setHasWaitDevnum(const ::mlir::ArrayAttr &propValue) {
      this->hasWaitDevnum = propValue;
    }
    using numGangsDeviceTypeTy = ::mlir::ArrayAttr;
    numGangsDeviceTypeTy numGangsDeviceType;

    auto getNumGangsDeviceType() {
      auto &propStorage = this->numGangsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setNumGangsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->numGangsDeviceType = propValue;
    }
    using numGangsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    numGangsSegmentsTy numGangsSegments;

    auto getNumGangsSegments() {
      auto &propStorage = this->numGangsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setNumGangsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->numGangsSegments = propValue;
    }
    using numWorkersDeviceTypeTy = ::mlir::ArrayAttr;
    numWorkersDeviceTypeTy numWorkersDeviceType;

    auto getNumWorkersDeviceType() {
      auto &propStorage = this->numWorkersDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setNumWorkersDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->numWorkersDeviceType = propValue;
    }
    using privatizationsTy = ::mlir::ArrayAttr;
    privatizationsTy privatizations;

    auto getPrivatizations() {
      auto &propStorage = this->privatizations;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivatizations(const ::mlir::ArrayAttr &propValue) {
      this->privatizations = propValue;
    }
    using reductionRecipesTy = ::mlir::ArrayAttr;
    reductionRecipesTy reductionRecipes;

    auto getReductionRecipes() {
      auto &propStorage = this->reductionRecipes;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionRecipes(const ::mlir::ArrayAttr &propValue) {
      this->reductionRecipes = propValue;
    }
    using selfAttrTy = ::mlir::UnitAttr;
    selfAttrTy selfAttr;

    auto getSelfAttr() {
      auto &propStorage = this->selfAttr;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setSelfAttr(const ::mlir::UnitAttr &propValue) {
      this->selfAttr = propValue;
    }
    using vectorLengthDeviceTypeTy = ::mlir::ArrayAttr;
    vectorLengthDeviceTypeTy vectorLengthDeviceType;

    auto getVectorLengthDeviceType() {
      auto &propStorage = this->vectorLengthDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setVectorLengthDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->vectorLengthDeviceType = propValue;
    }
    using waitOnlyTy = ::mlir::ArrayAttr;
    waitOnlyTy waitOnly;

    auto getWaitOnly() {
      auto &propStorage = this->waitOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOnly(const ::mlir::ArrayAttr &propValue) {
      this->waitOnly = propValue;
    }
    using waitOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    waitOperandsDeviceTypeTy waitOperandsDeviceType;

    auto getWaitOperandsDeviceType() {
      auto &propStorage = this->waitOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->waitOperandsDeviceType = propValue;
    }
    using waitOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    waitOperandsSegmentsTy waitOperandsSegments;

    auto getWaitOperandsSegments() {
      auto &propStorage = this->waitOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setWaitOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->waitOperandsSegments = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 11>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.asyncOnly == this->asyncOnly &&
        rhs.asyncOperandsDeviceType == this->asyncOperandsDeviceType &&
        rhs.defaultAttr == this->defaultAttr &&
        rhs.firstprivatizations == this->firstprivatizations &&
        rhs.hasWaitDevnum == this->hasWaitDevnum &&
        rhs.numGangsDeviceType == this->numGangsDeviceType &&
        rhs.numGangsSegments == this->numGangsSegments &&
        rhs.numWorkersDeviceType == this->numWorkersDeviceType &&
        rhs.privatizations == this->privatizations &&
        rhs.reductionRecipes == this->reductionRecipes &&
        rhs.selfAttr == this->selfAttr &&
        rhs.vectorLengthDeviceType == this->vectorLengthDeviceType &&
        rhs.waitOnly == this->waitOnly &&
        rhs.waitOperandsDeviceType == this->waitOperandsDeviceType &&
        rhs.waitOperandsSegments == this->waitOperandsSegments &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ParallelOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  ParallelOpGenericAdaptorBase(ParallelOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::DenseI32ArrayAttr getNumGangsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getNumGangsSegments();
  ::mlir::ArrayAttr getNumGangsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumGangsDeviceType();
  ::mlir::ArrayAttr getNumWorkersDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumWorkersDeviceType();
  ::mlir::ArrayAttr getVectorLengthDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getVectorLengthDeviceType();
  ::mlir::UnitAttr getSelfAttrAttr();
  bool getSelfAttr();
  ::mlir::ArrayAttr getReductionRecipesAttr();
  ::std::optional< ::mlir::ArrayAttr > getReductionRecipes();
  ::mlir::ArrayAttr getPrivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getPrivatizations();
  ::mlir::ArrayAttr getFirstprivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getFirstprivatizations();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class ParallelOpGenericAdaptor : public detail::ParallelOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ParallelOpGenericAdaptorBase;
public:
  ParallelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ParallelOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ParallelOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = ParallelOp, typename = std::enable_if_t<std::is_same_v<LateInst, ParallelOp>>>
  ParallelOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAsyncOperands() {
    return getODSOperands(0);
  }

  RangeT getWaitOperands() {
    return getODSOperands(1);
  }

  RangeT getNumGangs() {
    return getODSOperands(2);
  }

  RangeT getNumWorkers() {
    return getODSOperands(3);
  }

  RangeT getVectorLength() {
    return getODSOperands(4);
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(5);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getSelfCond() {
    auto operands = getODSOperands(6);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getReductionOperands() {
    return getODSOperands(7);
  }

  RangeT getGangPrivateOperands() {
    return getODSOperands(8);
  }

  RangeT getGangFirstPrivateOperands() {
    return getODSOperands(9);
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(10);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ParallelOpAdaptor : public ParallelOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ParallelOpGenericAdaptor::ParallelOpGenericAdaptor;
  ParallelOpAdaptor(ParallelOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ParallelOp : public ::mlir::Op<ParallelOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ParallelOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ParallelOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("asyncOnly"), ::llvm::StringRef("asyncOperandsDeviceType"), ::llvm::StringRef("defaultAttr"), ::llvm::StringRef("firstprivatizations"), ::llvm::StringRef("hasWaitDevnum"), ::llvm::StringRef("numGangsDeviceType"), ::llvm::StringRef("numGangsSegments"), ::llvm::StringRef("numWorkersDeviceType"), ::llvm::StringRef("privatizations"), ::llvm::StringRef("reductionRecipes"), ::llvm::StringRef("selfAttr"), ::llvm::StringRef("vectorLengthDeviceType"), ::llvm::StringRef("waitOnly"), ::llvm::StringRef("waitOperandsDeviceType"), ::llvm::StringRef("waitOperandsSegments"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncOnlyAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getDefaultAttrAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getDefaultAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getFirstprivatizationsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getFirstprivatizationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getHasWaitDevnumAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getHasWaitDevnumAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getNumGangsDeviceTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getNumGangsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getNumGangsSegmentsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getNumGangsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getNumWorkersDeviceTypeAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getNumWorkersDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getPrivatizationsAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getPrivatizationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getReductionRecipesAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getReductionRecipesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getSelfAttrAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getSelfAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getVectorLengthDeviceTypeAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getVectorLengthDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getWaitOnlyAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getWaitOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getWaitOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getWaitOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.parallel");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getAsyncOperands();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Operation::operand_range getNumGangs();
  ::mlir::Operation::operand_range getNumWorkers();
  ::mlir::Operation::operand_range getVectorLength();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::TypedValue<::mlir::IntegerType> getSelfCond();
  ::mlir::Operation::operand_range getReductionOperands();
  ::mlir::Operation::operand_range getGangPrivateOperands();
  ::mlir::Operation::operand_range getGangFirstPrivateOperands();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getAsyncOperandsMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getNumGangsMutable();
  ::mlir::MutableOperandRange getNumWorkersMutable();
  ::mlir::MutableOperandRange getVectorLengthMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getSelfCondMutable();
  ::mlir::MutableOperandRange getReductionOperandsMutable();
  ::mlir::MutableOperandRange getGangPrivateOperandsMutable();
  ::mlir::MutableOperandRange getGangFirstPrivateOperandsMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::DenseI32ArrayAttr getNumGangsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getNumGangsSegments();
  ::mlir::ArrayAttr getNumGangsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumGangsDeviceType();
  ::mlir::ArrayAttr getNumWorkersDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getNumWorkersDeviceType();
  ::mlir::ArrayAttr getVectorLengthDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getVectorLengthDeviceType();
  ::mlir::UnitAttr getSelfAttrAttr();
  bool getSelfAttr();
  ::mlir::ArrayAttr getReductionRecipesAttr();
  ::std::optional< ::mlir::ArrayAttr > getReductionRecipes();
  ::mlir::ArrayAttr getPrivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getPrivatizations();
  ::mlir::ArrayAttr getFirstprivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getFirstprivatizations();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  void setAsyncOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setAsyncOnlyAttr(::mlir::ArrayAttr attr);
  void setWaitOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setWaitOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setHasWaitDevnumAttr(::mlir::ArrayAttr attr);
  void setWaitOnlyAttr(::mlir::ArrayAttr attr);
  void setNumGangsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setNumGangsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setNumGangsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setNumWorkersDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setVectorLengthDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setSelfAttrAttr(::mlir::UnitAttr attr);
  void setSelfAttr(bool attrValue);
  void setReductionRecipesAttr(::mlir::ArrayAttr attr);
  void setPrivatizationsAttr(::mlir::ArrayAttr attr);
  void setFirstprivatizationsAttr(::mlir::ArrayAttr attr);
  void setDefaultAttrAttr(::mlir::acc::ClauseDefaultValueAttr attr);
  void setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue);
  ::mlir::Attribute removeAsyncOperandsDeviceTypeAttr();
  ::mlir::Attribute removeAsyncOnlyAttr();
  ::mlir::Attribute removeWaitOperandsSegmentsAttr();
  ::mlir::Attribute removeWaitOperandsDeviceTypeAttr();
  ::mlir::Attribute removeHasWaitDevnumAttr();
  ::mlir::Attribute removeWaitOnlyAttr();
  ::mlir::Attribute removeNumGangsSegmentsAttr();
  ::mlir::Attribute removeNumGangsDeviceTypeAttr();
  ::mlir::Attribute removeNumWorkersDeviceTypeAttr();
  ::mlir::Attribute removeVectorLengthDeviceTypeAttr();
  ::mlir::Attribute removeSelfAttrAttr();
  ::mlir::Attribute removeReductionRecipesAttr();
  ::mlir::Attribute removePrivatizationsAttr();
  ::mlir::Attribute removeFirstprivatizationsAttr();
  ::mlir::Attribute removeDefaultAttrAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 15 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);

  /// Return true if the op has the async attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasAsyncOnly();
  /// Return true if the op has the async attribute for the given device_type.
  bool hasAsyncOnly(mlir::acc::DeviceType deviceType);
  /// Return the value of the async clause if present.
  mlir::Value getAsyncValue();
  /// Return the value of the async clause for the given device_type if
  /// present.
  mlir::Value getAsyncValue(mlir::acc::DeviceType deviceType);

  /// Return the value of the num_workers clause if present.
  mlir::Value getNumWorkersValue();
  /// Return the value of the num_workers clause for the given device_type if
  /// present.
  mlir::Value getNumWorkersValue(mlir::acc::DeviceType deviceType);

  /// Return the value of the vector_length clause if present.
  mlir::Value getVectorLengthValue();
  /// Return the value of the vector_length clause for the given device_type 
  /// if present.
  mlir::Value getVectorLengthValue(mlir::acc::DeviceType deviceType);

  /// Return the values of the num_gangs clause if present.
  mlir::Operation::operand_range getNumGangsValues();
  /// Return the values of the num_gangs clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getNumGangsValues(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the wait attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWaitOnly();
  /// Return true if the op has the wait attribute for the given device_type.
  bool hasWaitOnly(mlir::acc::DeviceType deviceType);
  /// Return the values of the wait clause if present.
  mlir::Operation::operand_range getWaitValues();
  /// Return the values of the wait clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getWaitValues(mlir::acc::DeviceType deviceType);
  /// Return the wait devnum value clause if present;
  mlir::Value getWaitDevnum();
  /// Return the wait devnum value clause for the given device_type if
  /// present.
  mlir::Value getWaitDevnum(mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::ParallelOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::PresentOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PresentOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  PresentOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  PresentOpGenericAdaptorBase(PresentOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class PresentOpGenericAdaptor : public detail::PresentOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PresentOpGenericAdaptorBase;
public:
  PresentOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PresentOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PresentOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = PresentOp, typename = std::enable_if_t<std::is_same_v<LateInst, PresentOp>>>
  PresentOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PresentOpAdaptor : public PresentOpGenericAdaptor<::mlir::ValueRange> {
public:
  using PresentOpGenericAdaptor::PresentOpGenericAdaptor;
  PresentOpAdaptor(PresentOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PresentOp : public ::mlir::Op<PresentOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PresentOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = PresentOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.present");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::PresentOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::PrivateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PrivateOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  PrivateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  PrivateOpGenericAdaptorBase(PrivateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class PrivateOpGenericAdaptor : public detail::PrivateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PrivateOpGenericAdaptorBase;
public:
  PrivateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PrivateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PrivateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = PrivateOp, typename = std::enable_if_t<std::is_same_v<LateInst, PrivateOp>>>
  PrivateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PrivateOpAdaptor : public PrivateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using PrivateOpGenericAdaptor::PrivateOpGenericAdaptor;
  PrivateOpAdaptor(PrivateOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PrivateOp : public ::mlir::Op<PrivateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PrivateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = PrivateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.private");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::PrivateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::PrivateRecipeOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PrivateRecipeOpGenericAdaptorBase {
public:
  struct Properties {
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    using typeTy = ::mlir::TypeAttr;
    typeTy type;

    auto getType() {
      auto &propStorage = this->type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setType(const ::mlir::TypeAttr &propValue) {
      this->type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.sym_name == this->sym_name &&
        rhs.type == this->type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  PrivateRecipeOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  PrivateRecipeOpGenericAdaptorBase(PrivateRecipeOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr();
  ::mlir::Type getType();
  ::mlir::Region &getInitRegion();
  ::mlir::Region &getDestroyRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class PrivateRecipeOpGenericAdaptor : public detail::PrivateRecipeOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PrivateRecipeOpGenericAdaptorBase;
public:
  PrivateRecipeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PrivateRecipeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PrivateRecipeOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = PrivateRecipeOp, typename = std::enable_if_t<std::is_same_v<LateInst, PrivateRecipeOp>>>
  PrivateRecipeOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PrivateRecipeOpAdaptor : public PrivateRecipeOpGenericAdaptor<::mlir::ValueRange> {
public:
  using PrivateRecipeOpGenericAdaptor::PrivateRecipeOpGenericAdaptor;
  PrivateRecipeOpAdaptor(PrivateRecipeOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PrivateRecipeOp : public ::mlir::Op<PrivateRecipeOp, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::SymbolOpInterface::Trait, ::mlir::acc::RecipeInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PrivateRecipeOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = PrivateRecipeOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("sym_name"), ::llvm::StringRef("type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.private.recipe");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getInitRegion();
  ::mlir::Region &getDestroyRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr();
  ::mlir::Type getType();
  void setSymNameAttr(::mlir::StringAttr attr);
  void setSymName(::llvm::StringRef attrValue);
  void setTypeAttr(::mlir::TypeAttr attr);
  void setType(::mlir::Type attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::PrivateRecipeOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ReductionOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReductionOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReductionOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  ReductionOpGenericAdaptorBase(ReductionOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class ReductionOpGenericAdaptor : public detail::ReductionOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReductionOpGenericAdaptorBase;
public:
  ReductionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReductionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReductionOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = ReductionOp, typename = std::enable_if_t<std::is_same_v<LateInst, ReductionOp>>>
  ReductionOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReductionOpAdaptor : public ReductionOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ReductionOpGenericAdaptor::ReductionOpGenericAdaptor;
  ReductionOpAdaptor(ReductionOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReductionOp : public ::mlir::Op<ReductionOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReductionOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ReductionOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.reduction");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::ReductionOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ReductionRecipeOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReductionRecipeOpGenericAdaptorBase {
public:
  struct Properties {
    using reductionOperatorTy = ::mlir::acc::ReductionOperatorAttr;
    reductionOperatorTy reductionOperator;

    auto getReductionOperator() {
      auto &propStorage = this->reductionOperator;
      return ::llvm::cast<::mlir::acc::ReductionOperatorAttr>(propStorage);
    }
    void setReductionOperator(const ::mlir::acc::ReductionOperatorAttr &propValue) {
      this->reductionOperator = propValue;
    }
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    using typeTy = ::mlir::TypeAttr;
    typeTy type;

    auto getType() {
      auto &propStorage = this->type;
      return ::llvm::cast<::mlir::TypeAttr>(propStorage);
    }
    void setType(const ::mlir::TypeAttr &propValue) {
      this->type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.reductionOperator == this->reductionOperator &&
        rhs.sym_name == this->sym_name &&
        rhs.type == this->type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ReductionRecipeOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  ReductionRecipeOpGenericAdaptorBase(ReductionRecipeOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr();
  ::mlir::Type getType();
  ::mlir::acc::ReductionOperatorAttr getReductionOperatorAttr();
  ::mlir::acc::ReductionOperator getReductionOperator();
  ::mlir::Region &getInitRegion();
  ::mlir::Region &getCombinerRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class ReductionRecipeOpGenericAdaptor : public detail::ReductionRecipeOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReductionRecipeOpGenericAdaptorBase;
public:
  ReductionRecipeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReductionRecipeOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReductionRecipeOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = ReductionRecipeOp, typename = std::enable_if_t<std::is_same_v<LateInst, ReductionRecipeOp>>>
  ReductionRecipeOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReductionRecipeOpAdaptor : public ReductionRecipeOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ReductionRecipeOpGenericAdaptor::ReductionRecipeOpGenericAdaptor;
  ReductionRecipeOpAdaptor(ReductionRecipeOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReductionRecipeOp : public ::mlir::Op<ReductionRecipeOp, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove, ::mlir::SymbolOpInterface::Trait, ::mlir::acc::RecipeInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReductionRecipeOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ReductionRecipeOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("reductionOperator"), ::llvm::StringRef("sym_name"), ::llvm::StringRef("type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getReductionOperatorAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getReductionOperatorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getTypeAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.reduction.recipe");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getInitRegion();
  ::mlir::Region &getCombinerRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::TypeAttr getTypeAttr();
  ::mlir::Type getType();
  ::mlir::acc::ReductionOperatorAttr getReductionOperatorAttr();
  ::mlir::acc::ReductionOperator getReductionOperator();
  void setSymNameAttr(::mlir::StringAttr attr);
  void setSymName(::llvm::StringRef attrValue);
  void setTypeAttr(::mlir::TypeAttr attr);
  void setType(::mlir::Type attrValue);
  void setReductionOperatorAttr(::mlir::acc::ReductionOperatorAttr attr);
  void setReductionOperator(::mlir::acc::ReductionOperator attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type, ::mlir::acc::ReductionOperatorAttr reductionOperator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type, ::mlir::acc::ReductionOperatorAttr reductionOperator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type, ::mlir::acc::ReductionOperator reductionOperator);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type, ::mlir::acc::ReductionOperator reductionOperator);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verifyRegions();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::ReductionRecipeOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::RoutineOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RoutineOpGenericAdaptorBase {
public:
  struct Properties {
    using bindNameTy = ::mlir::ArrayAttr;
    bindNameTy bindName;

    auto getBindName() {
      auto &propStorage = this->bindName;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setBindName(const ::mlir::ArrayAttr &propValue) {
      this->bindName = propValue;
    }
    using bindNameDeviceTypeTy = ::mlir::ArrayAttr;
    bindNameDeviceTypeTy bindNameDeviceType;

    auto getBindNameDeviceType() {
      auto &propStorage = this->bindNameDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setBindNameDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->bindNameDeviceType = propValue;
    }
    using func_nameTy = ::mlir::StringAttr;
    func_nameTy func_name;

    auto getFuncName() {
      auto &propStorage = this->func_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setFuncName(const ::mlir::StringAttr &propValue) {
      this->func_name = propValue;
    }
    using gangTy = ::mlir::ArrayAttr;
    gangTy gang;

    auto getGang() {
      auto &propStorage = this->gang;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setGang(const ::mlir::ArrayAttr &propValue) {
      this->gang = propValue;
    }
    using gangDimTy = ::mlir::ArrayAttr;
    gangDimTy gangDim;

    auto getGangDim() {
      auto &propStorage = this->gangDim;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setGangDim(const ::mlir::ArrayAttr &propValue) {
      this->gangDim = propValue;
    }
    using gangDimDeviceTypeTy = ::mlir::ArrayAttr;
    gangDimDeviceTypeTy gangDimDeviceType;

    auto getGangDimDeviceType() {
      auto &propStorage = this->gangDimDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setGangDimDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->gangDimDeviceType = propValue;
    }
    using implicitTy = ::mlir::UnitAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setImplicit(const ::mlir::UnitAttr &propValue) {
      this->implicit = propValue;
    }
    using nohostTy = ::mlir::UnitAttr;
    nohostTy nohost;

    auto getNohost() {
      auto &propStorage = this->nohost;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setNohost(const ::mlir::UnitAttr &propValue) {
      this->nohost = propValue;
    }
    using seqTy = ::mlir::ArrayAttr;
    seqTy seq;

    auto getSeq() {
      auto &propStorage = this->seq;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setSeq(const ::mlir::ArrayAttr &propValue) {
      this->seq = propValue;
    }
    using sym_nameTy = ::mlir::StringAttr;
    sym_nameTy sym_name;

    auto getSymName() {
      auto &propStorage = this->sym_name;
      return ::llvm::cast<::mlir::StringAttr>(propStorage);
    }
    void setSymName(const ::mlir::StringAttr &propValue) {
      this->sym_name = propValue;
    }
    using vectorTy = ::mlir::ArrayAttr;
    vectorTy vector;

    auto getVector() {
      auto &propStorage = this->vector;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setVector(const ::mlir::ArrayAttr &propValue) {
      this->vector = propValue;
    }
    using workerTy = ::mlir::ArrayAttr;
    workerTy worker;

    auto getWorker() {
      auto &propStorage = this->worker;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWorker(const ::mlir::ArrayAttr &propValue) {
      this->worker = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.bindName == this->bindName &&
        rhs.bindNameDeviceType == this->bindNameDeviceType &&
        rhs.func_name == this->func_name &&
        rhs.gang == this->gang &&
        rhs.gangDim == this->gangDim &&
        rhs.gangDimDeviceType == this->gangDimDeviceType &&
        rhs.implicit == this->implicit &&
        rhs.nohost == this->nohost &&
        rhs.seq == this->seq &&
        rhs.sym_name == this->sym_name &&
        rhs.vector == this->vector &&
        rhs.worker == this->worker &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  RoutineOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  RoutineOpGenericAdaptorBase(RoutineOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::StringAttr getFuncNameAttr();
  ::llvm::StringRef getFuncName();
  ::mlir::ArrayAttr getBindNameAttr();
  ::std::optional< ::mlir::ArrayAttr > getBindName();
  ::mlir::ArrayAttr getBindNameDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getBindNameDeviceType();
  ::mlir::ArrayAttr getWorkerAttr();
  ::std::optional< ::mlir::ArrayAttr > getWorker();
  ::mlir::ArrayAttr getVectorAttr();
  ::std::optional< ::mlir::ArrayAttr > getVector();
  ::mlir::ArrayAttr getSeqAttr();
  ::std::optional< ::mlir::ArrayAttr > getSeq();
  ::mlir::UnitAttr getNohostAttr();
  bool getNohost();
  ::mlir::UnitAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::ArrayAttr getGangAttr();
  ::std::optional< ::mlir::ArrayAttr > getGang();
  ::mlir::ArrayAttr getGangDimAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangDim();
  ::mlir::ArrayAttr getGangDimDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangDimDeviceType();
};
} // namespace detail
template <typename RangeT>
class RoutineOpGenericAdaptor : public detail::RoutineOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RoutineOpGenericAdaptorBase;
public:
  RoutineOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RoutineOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RoutineOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = RoutineOp, typename = std::enable_if_t<std::is_same_v<LateInst, RoutineOp>>>
  RoutineOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RoutineOpAdaptor : public RoutineOpGenericAdaptor<::mlir::ValueRange> {
public:
  using RoutineOpGenericAdaptor::RoutineOpGenericAdaptor;
  RoutineOpAdaptor(RoutineOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RoutineOp : public ::mlir::Op<RoutineOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::IsIsolatedFromAbove> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RoutineOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = RoutineOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("bindName"), ::llvm::StringRef("bindNameDeviceType"), ::llvm::StringRef("func_name"), ::llvm::StringRef("gang"), ::llvm::StringRef("gangDim"), ::llvm::StringRef("gangDimDeviceType"), ::llvm::StringRef("implicit"), ::llvm::StringRef("nohost"), ::llvm::StringRef("seq"), ::llvm::StringRef("sym_name"), ::llvm::StringRef("vector"), ::llvm::StringRef("worker")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBindNameAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBindNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getBindNameDeviceTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getBindNameDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getFuncNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getFuncNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getGangAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getGangAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getGangDimAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getGangDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getGangDimDeviceTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getGangDimDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getNohostAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getNohostAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getSeqAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getSeqAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getVectorAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getVectorAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getWorkerAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getWorkerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.routine");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getSymNameAttr();
  ::llvm::StringRef getSymName();
  ::mlir::StringAttr getFuncNameAttr();
  ::llvm::StringRef getFuncName();
  ::mlir::ArrayAttr getBindNameAttr();
  ::std::optional< ::mlir::ArrayAttr > getBindName();
  ::mlir::ArrayAttr getBindNameDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getBindNameDeviceType();
  ::mlir::ArrayAttr getWorkerAttr();
  ::std::optional< ::mlir::ArrayAttr > getWorker();
  ::mlir::ArrayAttr getVectorAttr();
  ::std::optional< ::mlir::ArrayAttr > getVector();
  ::mlir::ArrayAttr getSeqAttr();
  ::std::optional< ::mlir::ArrayAttr > getSeq();
  ::mlir::UnitAttr getNohostAttr();
  bool getNohost();
  ::mlir::UnitAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::ArrayAttr getGangAttr();
  ::std::optional< ::mlir::ArrayAttr > getGang();
  ::mlir::ArrayAttr getGangDimAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangDim();
  ::mlir::ArrayAttr getGangDimDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getGangDimDeviceType();
  void setSymNameAttr(::mlir::StringAttr attr);
  void setSymName(::llvm::StringRef attrValue);
  void setFuncNameAttr(::mlir::StringAttr attr);
  void setFuncName(::llvm::StringRef attrValue);
  void setBindNameAttr(::mlir::ArrayAttr attr);
  void setBindNameDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setWorkerAttr(::mlir::ArrayAttr attr);
  void setVectorAttr(::mlir::ArrayAttr attr);
  void setSeqAttr(::mlir::ArrayAttr attr);
  void setNohostAttr(::mlir::UnitAttr attr);
  void setNohost(bool attrValue);
  void setImplicitAttr(::mlir::UnitAttr attr);
  void setImplicit(bool attrValue);
  void setGangAttr(::mlir::ArrayAttr attr);
  void setGangDimAttr(::mlir::ArrayAttr attr);
  void setGangDimDeviceTypeAttr(::mlir::ArrayAttr attr);
  ::mlir::Attribute removeBindNameAttr();
  ::mlir::Attribute removeBindNameDeviceTypeAttr();
  ::mlir::Attribute removeWorkerAttr();
  ::mlir::Attribute removeVectorAttr();
  ::mlir::Attribute removeSeqAttr();
  ::mlir::Attribute removeNohostAttr();
  ::mlir::Attribute removeImplicitAttr();
  ::mlir::Attribute removeGangAttr();
  ::mlir::Attribute removeGangDimAttr();
  ::mlir::Attribute removeGangDimDeviceTypeAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::StringAttr func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/::mlir::UnitAttr nohost, /*optional*/::mlir::UnitAttr implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::StringAttr func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/::mlir::UnitAttr nohost, /*optional*/::mlir::UnitAttr implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::llvm::StringRef func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/bool nohost, /*optional*/bool implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::llvm::StringRef func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/bool nohost, /*optional*/bool implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 12 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  static StringRef getGangDimKeyword() { return "dim"; }

  /// Return true if the op has the worker attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWorker();
  /// Return true if the op has the worker attribute for the given
  /// device_type.
  bool hasWorker(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the vector attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasVector();
  /// Return true if the op has the vector attribute for the given
  /// device_type.
  bool hasVector(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the seq attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasSeq();
  /// Return true if the op has the seq attribute for the given
  /// device_type.
  bool hasSeq(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the gang attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasGang();
  /// Return true if the op has the gang attribute for the given
  /// device_type.
  bool hasGang(mlir::acc::DeviceType deviceType);

  std::optional<int64_t> getGangDimValue();
  std::optional<int64_t> getGangDimValue(mlir::acc::DeviceType deviceType);

  std::optional<llvm::StringRef> getBindNameValue();
  std::optional<llvm::StringRef> getBindNameValue(mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::RoutineOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::SerialOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SerialOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncOnlyTy = ::mlir::ArrayAttr;
    asyncOnlyTy asyncOnly;

    auto getAsyncOnly() {
      auto &propStorage = this->asyncOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOnly(const ::mlir::ArrayAttr &propValue) {
      this->asyncOnly = propValue;
    }
    using asyncOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    asyncOperandsDeviceTypeTy asyncOperandsDeviceType;

    auto getAsyncOperandsDeviceType() {
      auto &propStorage = this->asyncOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->asyncOperandsDeviceType = propValue;
    }
    using defaultAttrTy = ::mlir::acc::ClauseDefaultValueAttr;
    defaultAttrTy defaultAttr;

    auto getDefaultAttr() {
      auto &propStorage = this->defaultAttr;
      return ::llvm::dyn_cast_or_null<::mlir::acc::ClauseDefaultValueAttr>(propStorage);
    }
    void setDefaultAttr(const ::mlir::acc::ClauseDefaultValueAttr &propValue) {
      this->defaultAttr = propValue;
    }
    using firstprivatizationsTy = ::mlir::ArrayAttr;
    firstprivatizationsTy firstprivatizations;

    auto getFirstprivatizations() {
      auto &propStorage = this->firstprivatizations;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setFirstprivatizations(const ::mlir::ArrayAttr &propValue) {
      this->firstprivatizations = propValue;
    }
    using hasWaitDevnumTy = ::mlir::ArrayAttr;
    hasWaitDevnumTy hasWaitDevnum;

    auto getHasWaitDevnum() {
      auto &propStorage = this->hasWaitDevnum;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setHasWaitDevnum(const ::mlir::ArrayAttr &propValue) {
      this->hasWaitDevnum = propValue;
    }
    using privatizationsTy = ::mlir::ArrayAttr;
    privatizationsTy privatizations;

    auto getPrivatizations() {
      auto &propStorage = this->privatizations;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrivatizations(const ::mlir::ArrayAttr &propValue) {
      this->privatizations = propValue;
    }
    using reductionRecipesTy = ::mlir::ArrayAttr;
    reductionRecipesTy reductionRecipes;

    auto getReductionRecipes() {
      auto &propStorage = this->reductionRecipes;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setReductionRecipes(const ::mlir::ArrayAttr &propValue) {
      this->reductionRecipes = propValue;
    }
    using selfAttrTy = ::mlir::UnitAttr;
    selfAttrTy selfAttr;

    auto getSelfAttr() {
      auto &propStorage = this->selfAttr;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setSelfAttr(const ::mlir::UnitAttr &propValue) {
      this->selfAttr = propValue;
    }
    using waitOnlyTy = ::mlir::ArrayAttr;
    waitOnlyTy waitOnly;

    auto getWaitOnly() {
      auto &propStorage = this->waitOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOnly(const ::mlir::ArrayAttr &propValue) {
      this->waitOnly = propValue;
    }
    using waitOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    waitOperandsDeviceTypeTy waitOperandsDeviceType;

    auto getWaitOperandsDeviceType() {
      auto &propStorage = this->waitOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->waitOperandsDeviceType = propValue;
    }
    using waitOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    waitOperandsSegmentsTy waitOperandsSegments;

    auto getWaitOperandsSegments() {
      auto &propStorage = this->waitOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setWaitOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->waitOperandsSegments = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 8>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.asyncOnly == this->asyncOnly &&
        rhs.asyncOperandsDeviceType == this->asyncOperandsDeviceType &&
        rhs.defaultAttr == this->defaultAttr &&
        rhs.firstprivatizations == this->firstprivatizations &&
        rhs.hasWaitDevnum == this->hasWaitDevnum &&
        rhs.privatizations == this->privatizations &&
        rhs.reductionRecipes == this->reductionRecipes &&
        rhs.selfAttr == this->selfAttr &&
        rhs.waitOnly == this->waitOnly &&
        rhs.waitOperandsDeviceType == this->waitOperandsDeviceType &&
        rhs.waitOperandsSegments == this->waitOperandsSegments &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SerialOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  SerialOpGenericAdaptorBase(SerialOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::UnitAttr getSelfAttrAttr();
  bool getSelfAttr();
  ::mlir::ArrayAttr getReductionRecipesAttr();
  ::std::optional< ::mlir::ArrayAttr > getReductionRecipes();
  ::mlir::ArrayAttr getPrivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getPrivatizations();
  ::mlir::ArrayAttr getFirstprivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getFirstprivatizations();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  ::mlir::Region &getRegion();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class SerialOpGenericAdaptor : public detail::SerialOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SerialOpGenericAdaptorBase;
public:
  SerialOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SerialOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SerialOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = SerialOp, typename = std::enable_if_t<std::is_same_v<LateInst, SerialOp>>>
  SerialOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getAsyncOperands() {
    return getODSOperands(0);
  }

  RangeT getWaitOperands() {
    return getODSOperands(1);
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getSelfCond() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getReductionOperands() {
    return getODSOperands(4);
  }

  RangeT getGangPrivateOperands() {
    return getODSOperands(5);
  }

  RangeT getGangFirstPrivateOperands() {
    return getODSOperands(6);
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(7);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SerialOpAdaptor : public SerialOpGenericAdaptor<::mlir::ValueRange> {
public:
  using SerialOpGenericAdaptor::SerialOpGenericAdaptor;
  SerialOpAdaptor(SerialOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SerialOp : public ::mlir::Op<SerialOp, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::HasRecursiveMemoryEffects, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SerialOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = SerialOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("asyncOnly"), ::llvm::StringRef("asyncOperandsDeviceType"), ::llvm::StringRef("defaultAttr"), ::llvm::StringRef("firstprivatizations"), ::llvm::StringRef("hasWaitDevnum"), ::llvm::StringRef("privatizations"), ::llvm::StringRef("reductionRecipes"), ::llvm::StringRef("selfAttr"), ::llvm::StringRef("waitOnly"), ::llvm::StringRef("waitOperandsDeviceType"), ::llvm::StringRef("waitOperandsSegments"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncOnlyAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getDefaultAttrAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getDefaultAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getFirstprivatizationsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getFirstprivatizationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getHasWaitDevnumAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getHasWaitDevnumAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getPrivatizationsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getPrivatizationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getReductionRecipesAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getReductionRecipesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getSelfAttrAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getSelfAttrAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getWaitOnlyAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getWaitOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getWaitOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getWaitOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.serial");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getAsyncOperands();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::TypedValue<::mlir::IntegerType> getSelfCond();
  ::mlir::Operation::operand_range getReductionOperands();
  ::mlir::Operation::operand_range getGangPrivateOperands();
  ::mlir::Operation::operand_range getGangFirstPrivateOperands();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getAsyncOperandsMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getSelfCondMutable();
  ::mlir::MutableOperandRange getReductionOperandsMutable();
  ::mlir::MutableOperandRange getGangPrivateOperandsMutable();
  ::mlir::MutableOperandRange getGangFirstPrivateOperandsMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getRegion();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOnly();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::UnitAttr getSelfAttrAttr();
  bool getSelfAttr();
  ::mlir::ArrayAttr getReductionRecipesAttr();
  ::std::optional< ::mlir::ArrayAttr > getReductionRecipes();
  ::mlir::ArrayAttr getPrivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getPrivatizations();
  ::mlir::ArrayAttr getFirstprivatizationsAttr();
  ::std::optional< ::mlir::ArrayAttr > getFirstprivatizations();
  ::mlir::acc::ClauseDefaultValueAttr getDefaultAttrAttr();
  ::std::optional<::mlir::acc::ClauseDefaultValue> getDefaultAttr();
  void setAsyncOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setAsyncOnlyAttr(::mlir::ArrayAttr attr);
  void setWaitOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setWaitOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setHasWaitDevnumAttr(::mlir::ArrayAttr attr);
  void setWaitOnlyAttr(::mlir::ArrayAttr attr);
  void setSelfAttrAttr(::mlir::UnitAttr attr);
  void setSelfAttr(bool attrValue);
  void setReductionRecipesAttr(::mlir::ArrayAttr attr);
  void setPrivatizationsAttr(::mlir::ArrayAttr attr);
  void setFirstprivatizationsAttr(::mlir::ArrayAttr attr);
  void setDefaultAttrAttr(::mlir::acc::ClauseDefaultValueAttr attr);
  void setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue);
  ::mlir::Attribute removeAsyncOperandsDeviceTypeAttr();
  ::mlir::Attribute removeAsyncOnlyAttr();
  ::mlir::Attribute removeWaitOperandsSegmentsAttr();
  ::mlir::Attribute removeWaitOperandsDeviceTypeAttr();
  ::mlir::Attribute removeHasWaitDevnumAttr();
  ::mlir::Attribute removeWaitOnlyAttr();
  ::mlir::Attribute removeSelfAttrAttr();
  ::mlir::Attribute removeReductionRecipesAttr();
  ::mlir::Attribute removePrivatizationsAttr();
  ::mlir::Attribute removeFirstprivatizationsAttr();
  ::mlir::Attribute removeDefaultAttrAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 11 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);

  /// Return true if the op has the async attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasAsyncOnly();
  /// Return true if the op has the async attribute for the given device_type.
  bool hasAsyncOnly(mlir::acc::DeviceType deviceType);
  /// Return the value of the async clause if present.
  mlir::Value getAsyncValue();
  /// Return the value of the async clause for the given device_type if
  /// present.
  mlir::Value getAsyncValue(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the wait attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWaitOnly();
  /// Return true if the op has the wait attribute for the given device_type.
  bool hasWaitOnly(mlir::acc::DeviceType deviceType);
  /// Return the values of the wait clause if present.
  mlir::Operation::operand_range getWaitValues();
  /// Return the values of the wait clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getWaitValues(mlir::acc::DeviceType deviceType);
  /// Return the wait devnum value clause if present;
  mlir::Value getWaitDevnum();
  /// Return the wait devnum value clause for the given device_type if
  /// present.
  mlir::Value getWaitDevnum(mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::SerialOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::SetOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SetOpGenericAdaptorBase {
public:
  struct Properties {
    using device_typeTy = ::mlir::acc::DeviceTypeAttr;
    device_typeTy device_type;

    auto getDeviceType() {
      auto &propStorage = this->device_type;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DeviceTypeAttr>(propStorage);
    }
    void setDeviceType(const ::mlir::acc::DeviceTypeAttr &propValue) {
      this->device_type = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.device_type == this->device_type &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  SetOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  SetOpGenericAdaptorBase(SetOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DeviceTypeAttr getDeviceTypeAttr();
  ::std::optional<::mlir::acc::DeviceType> getDeviceType();
};
} // namespace detail
template <typename RangeT>
class SetOpGenericAdaptor : public detail::SetOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SetOpGenericAdaptorBase;
public:
  SetOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SetOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SetOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = SetOp, typename = std::enable_if_t<std::is_same_v<LateInst, SetOp>>>
  SetOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getDefaultAsync() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getDeviceNum() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SetOpAdaptor : public SetOpGenericAdaptor<::mlir::ValueRange> {
public:
  using SetOpGenericAdaptor::SetOpGenericAdaptor;
  SetOpAdaptor(SetOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SetOp : public ::mlir::Op<SetOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SetOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = SetOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("device_type"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDeviceTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.set");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getDefaultAsync();
  ::mlir::Value getDeviceNum();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::MutableOperandRange getDefaultAsyncMutable();
  ::mlir::MutableOperandRange getDeviceNumMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DeviceTypeAttr getDeviceTypeAttr();
  ::std::optional<::mlir::acc::DeviceType> getDeviceType();
  void setDeviceTypeAttr(::mlir::acc::DeviceTypeAttr attr);
  void setDeviceType(::std::optional<::mlir::acc::DeviceType> attrValue);
  ::mlir::Attribute removeDeviceTypeAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::acc::DeviceTypeAttr device_type, /*optional*/::mlir::Value defaultAsync, /*optional*/::mlir::Value deviceNum, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::acc::DeviceTypeAttr device_type, /*optional*/::mlir::Value defaultAsync, /*optional*/::mlir::Value deviceNum, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::SetOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ShutdownOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShutdownOpGenericAdaptorBase {
public:
  struct Properties {
    using device_typesTy = ::mlir::ArrayAttr;
    device_typesTy device_types;

    auto getDeviceTypes() {
      auto &propStorage = this->device_types;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setDeviceTypes(const ::mlir::ArrayAttr &propValue) {
      this->device_types = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 2>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.device_types == this->device_types &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ShutdownOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  ShutdownOpGenericAdaptorBase(ShutdownOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getDeviceTypesAttr();
  ::std::optional< ::mlir::ArrayAttr > getDeviceTypes();
};
} // namespace detail
template <typename RangeT>
class ShutdownOpGenericAdaptor : public detail::ShutdownOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShutdownOpGenericAdaptorBase;
public:
  ShutdownOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShutdownOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShutdownOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = ShutdownOp, typename = std::enable_if_t<std::is_same_v<LateInst, ShutdownOp>>>
  ShutdownOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getDeviceNumOperand() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShutdownOpAdaptor : public ShutdownOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ShutdownOpGenericAdaptor::ShutdownOpGenericAdaptor;
  ShutdownOpAdaptor(ShutdownOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ShutdownOp : public ::mlir::Op<ShutdownOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShutdownOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ShutdownOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("device_types"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDeviceTypesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDeviceTypesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.shutdown");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getDeviceNumOperand();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::MutableOperandRange getDeviceNumOperandMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getDeviceTypesAttr();
  ::std::optional< ::mlir::ArrayAttr > getDeviceTypes();
  void setDeviceTypesAttr(::mlir::ArrayAttr attr);
  ::mlir::Attribute removeDeviceTypesAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::ShutdownOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::TerminatorOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TerminatorOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TerminatorOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TerminatorOpGenericAdaptorBase(TerminatorOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class TerminatorOpGenericAdaptor : public detail::TerminatorOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TerminatorOpGenericAdaptorBase;
public:
  TerminatorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TerminatorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TerminatorOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TerminatorOp, typename = std::enable_if_t<std::is_same_v<LateInst, TerminatorOp>>>
  TerminatorOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TerminatorOpAdaptor : public TerminatorOpGenericAdaptor<::mlir::ValueRange> {
public:
  using TerminatorOpGenericAdaptor::TerminatorOpGenericAdaptor;
  TerminatorOpAdaptor(TerminatorOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TerminatorOp : public ::mlir::Op<TerminatorOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::ConditionallySpeculatable::Trait, ::mlir::OpTrait::AlwaysSpeculatableImplTrait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::OpTrait::IsTerminator> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TerminatorOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = TerminatorOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.terminator");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::TerminatorOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UpdateDeviceOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UpdateDeviceOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  UpdateDeviceOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  UpdateDeviceOpGenericAdaptorBase(UpdateDeviceOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class UpdateDeviceOpGenericAdaptor : public detail::UpdateDeviceOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UpdateDeviceOpGenericAdaptorBase;
public:
  UpdateDeviceOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UpdateDeviceOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UpdateDeviceOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = UpdateDeviceOp, typename = std::enable_if_t<std::is_same_v<LateInst, UpdateDeviceOp>>>
  UpdateDeviceOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UpdateDeviceOpAdaptor : public UpdateDeviceOpGenericAdaptor<::mlir::ValueRange> {
public:
  using UpdateDeviceOpGenericAdaptor::UpdateDeviceOpGenericAdaptor;
  UpdateDeviceOpAdaptor(UpdateDeviceOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UpdateDeviceOp : public ::mlir::Op<UpdateDeviceOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UpdateDeviceOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = UpdateDeviceOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.update_device");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::UpdateDeviceOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UpdateHostOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UpdateHostOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  UpdateHostOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  UpdateHostOpGenericAdaptorBase(UpdateHostOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class UpdateHostOpGenericAdaptor : public detail::UpdateHostOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UpdateHostOpGenericAdaptorBase;
public:
  UpdateHostOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UpdateHostOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UpdateHostOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = UpdateHostOp, typename = std::enable_if_t<std::is_same_v<LateInst, UpdateHostOp>>>
  UpdateHostOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getAccPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtr() {
    return (*getODSOperands(1).begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UpdateHostOpAdaptor : public UpdateHostOpGenericAdaptor<::mlir::ValueRange> {
public:
  using UpdateHostOpGenericAdaptor::UpdateHostOpGenericAdaptor;
  UpdateHostOpAdaptor(UpdateHostOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UpdateHostOp : public ::mlir::Op<UpdateHostOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UpdateHostOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = UpdateHostOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.update_host");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getAccPtrMutable();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// Check if this is an acc update self.
  bool isSelf() {
    return getDataClause() == acc::DataClause::acc_update_self;
  }
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::UpdateHostOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UpdateOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UpdateOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncTy = ::mlir::ArrayAttr;
    asyncTy async;

    auto getAsync() {
      auto &propStorage = this->async;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsync(const ::mlir::ArrayAttr &propValue) {
      this->async = propValue;
    }
    using asyncOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    asyncOperandsDeviceTypeTy asyncOperandsDeviceType;

    auto getAsyncOperandsDeviceType() {
      auto &propStorage = this->asyncOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setAsyncOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->asyncOperandsDeviceType = propValue;
    }
    using hasWaitDevnumTy = ::mlir::ArrayAttr;
    hasWaitDevnumTy hasWaitDevnum;

    auto getHasWaitDevnum() {
      auto &propStorage = this->hasWaitDevnum;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setHasWaitDevnum(const ::mlir::ArrayAttr &propValue) {
      this->hasWaitDevnum = propValue;
    }
    using ifPresentTy = ::mlir::UnitAttr;
    ifPresentTy ifPresent;

    auto getIfPresent() {
      auto &propStorage = this->ifPresent;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setIfPresent(const ::mlir::UnitAttr &propValue) {
      this->ifPresent = propValue;
    }
    using waitOnlyTy = ::mlir::ArrayAttr;
    waitOnlyTy waitOnly;

    auto getWaitOnly() {
      auto &propStorage = this->waitOnly;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOnly(const ::mlir::ArrayAttr &propValue) {
      this->waitOnly = propValue;
    }
    using waitOperandsDeviceTypeTy = ::mlir::ArrayAttr;
    waitOperandsDeviceTypeTy waitOperandsDeviceType;

    auto getWaitOperandsDeviceType() {
      auto &propStorage = this->waitOperandsDeviceType;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setWaitOperandsDeviceType(const ::mlir::ArrayAttr &propValue) {
      this->waitOperandsDeviceType = propValue;
    }
    using waitOperandsSegmentsTy = ::mlir::DenseI32ArrayAttr;
    waitOperandsSegmentsTy waitOperandsSegments;

    auto getWaitOperandsSegments() {
      auto &propStorage = this->waitOperandsSegments;
      return ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(propStorage);
    }
    void setWaitOperandsSegments(const ::mlir::DenseI32ArrayAttr &propValue) {
      this->waitOperandsSegments = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.async == this->async &&
        rhs.asyncOperandsDeviceType == this->asyncOperandsDeviceType &&
        rhs.hasWaitDevnum == this->hasWaitDevnum &&
        rhs.ifPresent == this->ifPresent &&
        rhs.waitOnly == this->waitOnly &&
        rhs.waitOperandsDeviceType == this->waitOperandsDeviceType &&
        rhs.waitOperandsSegments == this->waitOperandsSegments &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  UpdateOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  UpdateOpGenericAdaptorBase(UpdateOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsync();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::UnitAttr getIfPresentAttr();
  bool getIfPresent();
};
} // namespace detail
template <typename RangeT>
class UpdateOpGenericAdaptor : public detail::UpdateOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UpdateOpGenericAdaptorBase;
public:
  UpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UpdateOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UpdateOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = UpdateOp, typename = std::enable_if_t<std::is_same_v<LateInst, UpdateOp>>>
  UpdateOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(0);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getAsyncOperands() {
    return getODSOperands(1);
  }

  RangeT getWaitOperands() {
    return getODSOperands(2);
  }

  RangeT getDataClauseOperands() {
    return getODSOperands(3);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UpdateOpAdaptor : public UpdateOpGenericAdaptor<::mlir::ValueRange> {
public:
  using UpdateOpGenericAdaptor::UpdateOpGenericAdaptor;
  UpdateOpAdaptor(UpdateOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UpdateOp : public ::mlir::Op<UpdateOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UpdateOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = UpdateOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("async"), ::llvm::StringRef("asyncOperandsDeviceType"), ::llvm::StringRef("hasWaitDevnum"), ::llvm::StringRef("ifPresent"), ::llvm::StringRef("waitOnly"), ::llvm::StringRef("waitOperandsDeviceType"), ::llvm::StringRef("waitOperandsSegments"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getAsyncOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getHasWaitDevnumAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getHasWaitDevnumAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getIfPresentAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getIfPresentAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getWaitOnlyAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getWaitOnlyAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getWaitOperandsDeviceTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getWaitOperandsSegmentsAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getWaitOperandsSegmentsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.update");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::Operation::operand_range getAsyncOperands();
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Operation::operand_range getDataClauseOperands();
  ::mlir::MutableOperandRange getIfCondMutable();
  ::mlir::MutableOperandRange getAsyncOperandsMutable();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getDataClauseOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::ArrayAttr getAsyncOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsyncOperandsDeviceType();
  ::mlir::ArrayAttr getAsyncAttr();
  ::std::optional< ::mlir::ArrayAttr > getAsync();
  ::mlir::DenseI32ArrayAttr getWaitOperandsSegmentsAttr();
  ::std::optional<::llvm::ArrayRef<int32_t>> getWaitOperandsSegments();
  ::mlir::ArrayAttr getWaitOperandsDeviceTypeAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOperandsDeviceType();
  ::mlir::ArrayAttr getHasWaitDevnumAttr();
  ::std::optional< ::mlir::ArrayAttr > getHasWaitDevnum();
  ::mlir::ArrayAttr getWaitOnlyAttr();
  ::std::optional< ::mlir::ArrayAttr > getWaitOnly();
  ::mlir::UnitAttr getIfPresentAttr();
  bool getIfPresent();
  void setAsyncOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setAsyncAttr(::mlir::ArrayAttr attr);
  void setWaitOperandsSegmentsAttr(::mlir::DenseI32ArrayAttr attr);
  void setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue);
  void setWaitOperandsDeviceTypeAttr(::mlir::ArrayAttr attr);
  void setHasWaitDevnumAttr(::mlir::ArrayAttr attr);
  void setWaitOnlyAttr(::mlir::ArrayAttr attr);
  void setIfPresentAttr(::mlir::UnitAttr attr);
  void setIfPresent(bool attrValue);
  ::mlir::Attribute removeAsyncOperandsDeviceTypeAttr();
  ::mlir::Attribute removeAsyncAttr();
  ::mlir::Attribute removeWaitOperandsSegmentsAttr();
  ::mlir::Attribute removeWaitOperandsDeviceTypeAttr();
  ::mlir::Attribute removeHasWaitDevnumAttr();
  ::mlir::Attribute removeWaitOnlyAttr();
  ::mlir::Attribute removeIfPresentAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent = false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent = false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 7 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  /// The number of data operands.
  unsigned getNumDataOperands();

  /// The i-th data operand passed.
  Value getDataOperand(unsigned i);

  /// Return true if the op has the async attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasAsyncOnly();
  /// Return true if the op has the async attribute for the given device_type.
  bool hasAsyncOnly(mlir::acc::DeviceType deviceType);
  /// Return the value of the async clause if present.
  mlir::Value getAsyncValue();
  /// Return the value of the async clause for the given device_type if
  /// present.
  mlir::Value getAsyncValue(mlir::acc::DeviceType deviceType);

  /// Return true if the op has the wait attribute for the
  /// mlir::acc::DeviceType::None device_type.
  bool hasWaitOnly();
  /// Return true if the op has the wait attribute for the given device_type.
  bool hasWaitOnly(mlir::acc::DeviceType deviceType);
  /// Return the values of the wait clause if present.
  mlir::Operation::operand_range getWaitValues();
  /// Return the values of the wait clause for the given device_type if
  /// present.
  mlir::Operation::operand_range
  getWaitValues(mlir::acc::DeviceType deviceType);
  /// Return the wait devnum value clause if present;
  mlir::Value getWaitDevnum();
  /// Return the wait devnum value clause for the given device_type if
  /// present.
  mlir::Value getWaitDevnum(mlir::acc::DeviceType deviceType);
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::UpdateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UseDeviceOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UseDeviceOpGenericAdaptorBase {
public:
  struct Properties {
    using dataClauseTy = ::mlir::acc::DataClauseAttr;
    dataClauseTy dataClause;

    auto getDataClause() {
      auto &propStorage = this->dataClause;
      return ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(propStorage);
    }
    void setDataClause(const ::mlir::acc::DataClauseAttr &propValue) {
      this->dataClause = propValue;
    }
    using implicitTy = ::mlir::BoolAttr;
    implicitTy implicit;

    auto getImplicit() {
      auto &propStorage = this->implicit;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setImplicit(const ::mlir::BoolAttr &propValue) {
      this->implicit = propValue;
    }
    using nameTy = ::mlir::StringAttr;
    nameTy name;

    auto getName() {
      auto &propStorage = this->name;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setName(const ::mlir::StringAttr &propValue) {
      this->name = propValue;
    }
    using structuredTy = ::mlir::BoolAttr;
    structuredTy structured;

    auto getStructured() {
      auto &propStorage = this->structured;
      return ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(propStorage);
    }
    void setStructured(const ::mlir::BoolAttr &propValue) {
      this->structured = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 3>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.dataClause == this->dataClause &&
        rhs.implicit == this->implicit &&
        rhs.name == this->name &&
        rhs.structured == this->structured &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  UseDeviceOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  UseDeviceOpGenericAdaptorBase(UseDeviceOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
};
} // namespace detail
template <typename RangeT>
class UseDeviceOpGenericAdaptor : public detail::UseDeviceOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UseDeviceOpGenericAdaptorBase;
public:
  UseDeviceOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UseDeviceOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UseDeviceOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = UseDeviceOp, typename = std::enable_if_t<std::is_same_v<LateInst, UseDeviceOp>>>
  UseDeviceOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getVarPtr() {
    return (*getODSOperands(0).begin());
  }

  ValueT getVarPtrPtr() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getBounds() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UseDeviceOpAdaptor : public UseDeviceOpGenericAdaptor<::mlir::ValueRange> {
public:
  using UseDeviceOpGenericAdaptor::UseDeviceOpGenericAdaptor;
  UseDeviceOpAdaptor(UseDeviceOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UseDeviceOp : public ::mlir::Op<UseDeviceOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::acc::PointerLikeType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::MemoryEffectOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UseDeviceOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = UseDeviceOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dataClause"), ::llvm::StringRef("implicit"), ::llvm::StringRef("name"), ::llvm::StringRef("structured"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDataClauseAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDataClauseAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getImplicitAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getImplicitAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getStructuredAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getStructuredAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.use_device");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtr();
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getVarPtrPtr();
  ::mlir::Operation::operand_range getBounds();
  ::mlir::OpOperand &getVarPtrMutable();
  ::mlir::MutableOperandRange getVarPtrPtrMutable();
  ::mlir::MutableOperandRange getBoundsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::TypedValue<::mlir::acc::PointerLikeType> getAccPtr();
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::acc::DataClauseAttr getDataClauseAttr();
  ::mlir::acc::DataClause getDataClause();
  ::mlir::BoolAttr getStructuredAttr();
  bool getStructured();
  ::mlir::BoolAttr getImplicitAttr();
  bool getImplicit();
  ::mlir::StringAttr getNameAttr();
  ::std::optional< ::llvm::StringRef > getName();
  void setDataClauseAttr(::mlir::acc::DataClauseAttr attr);
  void setDataClause(::mlir::acc::DataClause attrValue);
  void setStructuredAttr(::mlir::BoolAttr attr);
  void setStructured(bool attrValue);
  void setImplicitAttr(::mlir::BoolAttr attr);
  void setImplicit(bool attrValue);
  void setNameAttr(::mlir::StringAttr attr);
  void setName(::std::optional<::llvm::StringRef> attrValue);
  ::mlir::Attribute removeNameAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::UseDeviceOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::WaitOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class WaitOpGenericAdaptorBase {
public:
  struct Properties {
    using asyncTy = ::mlir::UnitAttr;
    asyncTy async;

    auto getAsync() {
      auto &propStorage = this->async;
      return ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(propStorage);
    }
    void setAsync(const ::mlir::UnitAttr &propValue) {
      this->async = propValue;
    }
    using operandSegmentSizesTy = std::array<int32_t, 4>;
    operandSegmentSizesTy operandSegmentSizes;
    ::llvm::ArrayRef<int32_t> getOperandSegmentSizes() {
      auto &propStorage = this->operandSegmentSizes;
      return propStorage;
    }
    void setOperandSegmentSizes(const ::llvm::ArrayRef<int32_t> &propValue) {
      auto &propStorage = this->operandSegmentSizes;
      ::llvm::copy(propValue, propStorage.begin());
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.async == this->async &&
        rhs.operandSegmentSizes == this->operandSegmentSizes &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  WaitOpGenericAdaptorBase(::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  WaitOpGenericAdaptorBase(WaitOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes();
  ::mlir::UnitAttr getAsyncAttr();
  bool getAsync();
};
} // namespace detail
template <typename RangeT>
class WaitOpGenericAdaptor : public detail::WaitOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::WaitOpGenericAdaptorBase;
public:
  WaitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  WaitOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : WaitOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = WaitOp, typename = std::enable_if_t<std::is_same_v<LateInst, WaitOp>>>
  WaitOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getWaitOperands() {
    return getODSOperands(0);
  }

  ValueT getAsyncOperand() {
    auto operands = getODSOperands(1);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getWaitDevnum() {
    auto operands = getODSOperands(2);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  ValueT getIfCond() {
    auto operands = getODSOperands(3);
    return operands.empty() ? ValueT{} : (*operands.begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class WaitOpAdaptor : public WaitOpGenericAdaptor<::mlir::ValueRange> {
public:
  using WaitOpGenericAdaptor::WaitOpGenericAdaptor;
  WaitOpAdaptor(WaitOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class WaitOp : public ::mlir::Op<WaitOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::AttrSizedOperandSegments, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WaitOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = WaitOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("async"), ::llvm::StringRef("operandSegmentSizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAsyncAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAsyncAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getOperandSegmentSizesAttrName() {
   return (*this)->getName().getAttributeNames().back();
  }

  static ::mlir::StringAttr getOperandSegmentSizesAttrName(::mlir::OperationName name) {
   return name.getAttributeNames().back();
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.wait");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getWaitOperands();
  ::mlir::Value getAsyncOperand();
  ::mlir::Value getWaitDevnum();
  ::mlir::TypedValue<::mlir::IntegerType> getIfCond();
  ::mlir::MutableOperandRange getWaitOperandsMutable();
  ::mlir::MutableOperandRange getAsyncOperandMutable();
  ::mlir::MutableOperandRange getWaitDevnumMutable();
  ::mlir::MutableOperandRange getIfCondMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::UnitAttr getAsyncAttr();
  bool getAsync();
  void setAsyncAttr(::mlir::UnitAttr attr);
  void setAsync(bool attrValue);
  ::mlir::Attribute removeAsyncAttr();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/bool async, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/bool async, /*optional*/::mlir::Value ifCond);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::WaitOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::YieldOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class YieldOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  YieldOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  YieldOpGenericAdaptorBase(YieldOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class YieldOpGenericAdaptor : public detail::YieldOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::YieldOpGenericAdaptorBase;
public:
  YieldOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  YieldOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : YieldOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = YieldOp, typename = std::enable_if_t<std::is_same_v<LateInst, YieldOp>>>
  YieldOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return getODSOperands(0);
  }

private:
  RangeT odsOperands;
};
class YieldOpAdaptor : public YieldOpGenericAdaptor<::mlir::ValueRange> {
public:
  using YieldOpGenericAdaptor::YieldOpGenericAdaptor;
  YieldOpAdaptor(YieldOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class YieldOp : public ::mlir::Op<YieldOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::HasParent<FirstprivateRecipeOp, LoopOp, ParallelOp, PrivateRecipeOp,ReductionRecipeOp, SerialOp, AtomicUpdateOp>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::ConditionallySpeculatable::Trait, ::mlir::OpTrait::AlwaysSpeculatableImplTrait, ::mlir::MemoryEffectOpInterface::Trait, ::mlir::RegionBranchTerminatorOpInterface::Trait, ::mlir::OpTrait::ReturnLike, ::mlir::OpTrait::IsTerminator> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = YieldOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = YieldOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("acc.yield");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getOperands();
  ::mlir::MutableOperandRange getOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::MutableOperandRange getMutableSuccessorOperands(::mlir::RegionBranchPoint point);
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
  void getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects);
public:
};
} // namespace acc
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::acc::YieldOp)


#endif  // GET_OP_CLASSES

