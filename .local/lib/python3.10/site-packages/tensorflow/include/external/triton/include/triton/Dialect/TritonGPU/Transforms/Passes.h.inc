/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#define GEN_PASS_DECL_TRITONGPUCOALESCE
#define GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#define GEN_PASS_DECL_TRITONGPUOPTIMIZEEPILOGUE
#define GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#define GEN_PASS_DECL_TRITONGPUPIPELINE
#define GEN_PASS_DECL_TRITONGPUPREFETCH
#define GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#define GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#define GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// TritonGPUAccelerateMatmul
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
struct TritonGPUAccelerateMatmulOptions {
  int32_t computeCapability = 80;
};
#undef GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#endif // GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#ifdef GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL
namespace impl {

template <typename DerivedT>
class TritonGPUAccelerateMatmulBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAccelerateMatmulBase;

  TritonGPUAccelerateMatmulBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-accelerate-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-accelerate-matmul"; }

  ::llvm::StringRef getDescription() const override { return "accelerate matmul"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAccelerateMatmul");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAccelerateMatmul"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAccelerateMatmulBase<DerivedT>)

  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulOptions &options) : TritonGPUAccelerateMatmulBase() {
    computeCapability = options.computeCapability;
  }
protected:
  ::mlir::Pass::Option<int32_t> computeCapability{*this, "compute-capability", ::llvm::cl::desc("device compute capability"), ::llvm::cl::init(80)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL
#endif // GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL

//===----------------------------------------------------------------------===//
// TritonGPUCoalesce
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUCOALESCE
#undef GEN_PASS_DECL_TRITONGPUCOALESCE
#endif // GEN_PASS_DECL_TRITONGPUCOALESCE
#ifdef GEN_PASS_DEF_TRITONGPUCOALESCE
namespace impl {

template <typename DerivedT>
class TritonGPUCoalesceBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceBase;

  TritonGPUCoalesceBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceBase(const TritonGPUCoalesceBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce"; }

  ::llvm::StringRef getDescription() const override { return "coalesce"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesce");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesce"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUCOALESCE
#endif // GEN_PASS_DEF_TRITONGPUCOALESCE

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeDotOperands
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeDotOperandsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeDotOperandsBase;

  TritonGPUOptimizeDotOperandsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeDotOperandsBase(const TritonGPUOptimizeDotOperandsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-dot-operands");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-dot-operands"; }

  ::llvm::StringRef getDescription() const override { return "fuse transpositions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeDotOperands");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeDotOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeDotOperandsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeEpilogue
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZEEPILOGUE
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZEEPILOGUE
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZEEPILOGUE
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZEEPILOGUE
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeEpilogueBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeEpilogueBase;

  TritonGPUOptimizeEpilogueBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeEpilogueBase(const TritonGPUOptimizeEpilogueBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-epilogue");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-epilogue"; }

  ::llvm::StringRef getDescription() const override { return "Optimize epilogue: (1) Store accumulators directly without going thorough SMEM in epilogue."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeEpilogue");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeEpilogue"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeEpilogueBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZEEPILOGUE
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZEEPILOGUE

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeThreadLocality
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZETHREADLOCALITY
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeThreadLocalityBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeThreadLocalityBase;

  TritonGPUOptimizeThreadLocalityBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeThreadLocalityBase(const TritonGPUOptimizeThreadLocalityBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-thread-locality");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-thread-locality"; }

  ::llvm::StringRef getDescription() const override { return "Reduce the cost of synchronization between threads in an SM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeThreadLocality");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeThreadLocality"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeThreadLocalityBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZETHREADLOCALITY
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZETHREADLOCALITY

//===----------------------------------------------------------------------===//
// TritonGPUPipeline
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPIPELINE
struct TritonGPUPipelineOptions {
  int32_t numStages = 3;
  int32_t numWarps = 4;
  int32_t numCTAs = 1;
  int32_t computeCapability = 80;
};
#undef GEN_PASS_DECL_TRITONGPUPIPELINE
#endif // GEN_PASS_DECL_TRITONGPUPIPELINE
#ifdef GEN_PASS_DEF_TRITONGPUPIPELINE
namespace impl {

template <typename DerivedT>
class TritonGPUPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPipelineBase;

  TritonGPUPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPipelineBase(const TritonGPUPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-pipeline"; }

  ::llvm::StringRef getDescription() const override { return "pipeline"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPipeline");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPipelineBase<DerivedT>)

  TritonGPUPipelineBase(const TritonGPUPipelineOptions &options) : TritonGPUPipelineBase() {
    numStages = options.numStages;
    numWarps = options.numWarps;
    numCTAs = options.numCTAs;
    computeCapability = options.computeCapability;
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc("number of pipeline stages"), ::llvm::cl::init(3)};
  ::mlir::Pass::Option<int32_t> numWarps{*this, "num-warps", ::llvm::cl::desc("number of warps per block"), ::llvm::cl::init(4)};
  ::mlir::Pass::Option<int32_t> numCTAs{*this, "num-ctas", ::llvm::cl::desc("number of CTAs per CGA"), ::llvm::cl::init(1)};
  ::mlir::Pass::Option<int32_t> computeCapability{*this, "compute-capability", ::llvm::cl::desc("device compute capability"), ::llvm::cl::init(80)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUPIPELINE
#endif // GEN_PASS_DEF_TRITONGPUPIPELINE

//===----------------------------------------------------------------------===//
// TritonGPUPrefetch
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPREFETCH
#undef GEN_PASS_DECL_TRITONGPUPREFETCH
#endif // GEN_PASS_DECL_TRITONGPUPREFETCH
#ifdef GEN_PASS_DEF_TRITONGPUPREFETCH
namespace impl {

template <typename DerivedT>
class TritonGPUPrefetchBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPrefetchBase;

  TritonGPUPrefetchBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPrefetchBase(const TritonGPUPrefetchBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-prefetch");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-prefetch"; }

  ::llvm::StringRef getDescription() const override { return "prefetch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPrefetch");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPrefetch"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPrefetchBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUPREFETCH
#endif // GEN_PASS_DEF_TRITONGPUPREFETCH

//===----------------------------------------------------------------------===//
// TritonGPUReduceDataDuplication
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#undef GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#endif // GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#ifdef GEN_PASS_DEF_TRITONGPUREDUCEDATADUPLICATION
namespace impl {

template <typename DerivedT>
class TritonGPUReduceDataDuplicationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReduceDataDuplicationBase;

  TritonGPUReduceDataDuplicationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReduceDataDuplicationBase(const TritonGPUReduceDataDuplicationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reduce-data-duplication");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reduce-data-duplication"; }

  ::llvm::StringRef getDescription() const override { return "Reduce data duplication in register by decomposing convert[distributed -> dotOperand] into convert[distributed -> shared -> dotOperand]"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReduceDataDuplication");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReduceDataDuplication"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReduceDataDuplicationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUREDUCEDATADUPLICATION
#endif // GEN_PASS_DEF_TRITONGPUREDUCEDATADUPLICATION

//===----------------------------------------------------------------------===//
// TritonGPURemoveLayoutConversions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#undef GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#endif // GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#ifdef GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS
namespace impl {

template <typename DerivedT>
class TritonGPURemoveLayoutConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURemoveLayoutConversionsBase;

  TritonGPURemoveLayoutConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURemoveLayoutConversionsBase(const TritonGPURemoveLayoutConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-remove-layout-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-remove-layout-conversions"; }

  ::llvm::StringRef getDescription() const override { return "remove superfluous layout conversions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURemoveLayoutConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURemoveLayoutConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURemoveLayoutConversionsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS
#endif // GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS

//===----------------------------------------------------------------------===//
// TritonGPUReorderInstructions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#undef GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#endif // GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#ifdef GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
namespace impl {

template <typename DerivedT>
class TritonGPUReorderInstructionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReorderInstructionsBase;

  TritonGPUReorderInstructionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReorderInstructionsBase(const TritonGPUReorderInstructionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reorder-instructions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reorder-instructions"; }

  ::llvm::StringRef getDescription() const override { return "Reorder instructions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReorderInstructions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReorderInstructions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReorderInstructionsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
#endif // GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TritonGPUAccelerateMatmul Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUAccelerateMatmul() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createAccelerateMatmulPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUAccelerateMatmulPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createAccelerateMatmulPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUCoalesce Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUCoalesce() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createCoalescePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUCoalescePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createCoalescePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeDotOperands Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeDotOperands() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createOptimizeDotOperandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeDotOperandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createOptimizeDotOperandsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeEpilogue Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeEpilogue() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createOptimizeEpiloguePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeEpiloguePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createOptimizeEpiloguePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeThreadLocality Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeThreadLocality() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createOptimizeThreadLocalityPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeThreadLocalityPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createOptimizeThreadLocalityPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPipeline Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPipeline() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createPipelinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPipelinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createPipelinePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPrefetch Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPrefetch() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createPrefetchPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPrefetchPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createPrefetchPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUReduceDataDuplication Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUReduceDataDuplication() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createReduceDataDuplicationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUReduceDataDuplicationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createReduceDataDuplicationPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPURemoveLayoutConversions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPURemoveLayoutConversions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createRemoveLayoutConversionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPURemoveLayoutConversionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createRemoveLayoutConversionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUReorderInstructions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUReorderInstructions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createReorderInstructionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUReorderInstructionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::gpu::createReorderInstructionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPU Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPasses() {
  registerTritonGPUAccelerateMatmul();
  registerTritonGPUCoalesce();
  registerTritonGPUOptimizeDotOperands();
  registerTritonGPUOptimizeEpilogue();
  registerTritonGPUOptimizeThreadLocality();
  registerTritonGPUPipeline();
  registerTritonGPUPrefetch();
  registerTritonGPUReduceDataDuplication();
  registerTritonGPURemoveLayoutConversions();
  registerTritonGPUReorderInstructions();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class TritonGPUAccelerateMatmulBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAccelerateMatmulBase;

  TritonGPUAccelerateMatmulBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-accelerate-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-accelerate-matmul"; }

  ::llvm::StringRef getDescription() const override { return "accelerate matmul"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAccelerateMatmul");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAccelerateMatmul"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAccelerateMatmulBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> computeCapability{*this, "compute-capability", ::llvm::cl::desc("device compute capability"), ::llvm::cl::init(80)};
};

template <typename DerivedT>
class TritonGPUCoalesceBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceBase;

  TritonGPUCoalesceBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceBase(const TritonGPUCoalesceBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce"; }

  ::llvm::StringRef getDescription() const override { return "coalesce"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesce");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesce"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUOptimizeDotOperandsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeDotOperandsBase;

  TritonGPUOptimizeDotOperandsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeDotOperandsBase(const TritonGPUOptimizeDotOperandsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-dot-operands");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-dot-operands"; }

  ::llvm::StringRef getDescription() const override { return "fuse transpositions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeDotOperands");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeDotOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeDotOperandsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUOptimizeEpilogueBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeEpilogueBase;

  TritonGPUOptimizeEpilogueBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeEpilogueBase(const TritonGPUOptimizeEpilogueBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-epilogue");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-epilogue"; }

  ::llvm::StringRef getDescription() const override { return "Optimize epilogue: (1) Store accumulators directly without going thorough SMEM in epilogue."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeEpilogue");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeEpilogue"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeEpilogueBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUOptimizeThreadLocalityBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeThreadLocalityBase;

  TritonGPUOptimizeThreadLocalityBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeThreadLocalityBase(const TritonGPUOptimizeThreadLocalityBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-thread-locality");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-thread-locality"; }

  ::llvm::StringRef getDescription() const override { return "Reduce the cost of synchronization between threads in an SM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeThreadLocality");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeThreadLocality"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeThreadLocalityBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPipelineBase;

  TritonGPUPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPipelineBase(const TritonGPUPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-pipeline"; }

  ::llvm::StringRef getDescription() const override { return "pipeline"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPipeline");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPipelineBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc("number of pipeline stages"), ::llvm::cl::init(3)};
  ::mlir::Pass::Option<int32_t> numWarps{*this, "num-warps", ::llvm::cl::desc("number of warps per block"), ::llvm::cl::init(4)};
  ::mlir::Pass::Option<int32_t> numCTAs{*this, "num-ctas", ::llvm::cl::desc("number of CTAs per CGA"), ::llvm::cl::init(1)};
  ::mlir::Pass::Option<int32_t> computeCapability{*this, "compute-capability", ::llvm::cl::desc("device compute capability"), ::llvm::cl::init(80)};
};

template <typename DerivedT>
class TritonGPUPrefetchBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPrefetchBase;

  TritonGPUPrefetchBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPrefetchBase(const TritonGPUPrefetchBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-prefetch");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-prefetch"; }

  ::llvm::StringRef getDescription() const override { return "prefetch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPrefetch");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPrefetch"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPrefetchBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUReduceDataDuplicationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReduceDataDuplicationBase;

  TritonGPUReduceDataDuplicationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReduceDataDuplicationBase(const TritonGPUReduceDataDuplicationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reduce-data-duplication");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reduce-data-duplication"; }

  ::llvm::StringRef getDescription() const override { return "Reduce data duplication in register by decomposing convert[distributed -> dotOperand] into convert[distributed -> shared -> dotOperand]"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReduceDataDuplication");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReduceDataDuplication"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReduceDataDuplicationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPURemoveLayoutConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURemoveLayoutConversionsBase;

  TritonGPURemoveLayoutConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURemoveLayoutConversionsBase(const TritonGPURemoveLayoutConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-remove-layout-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-remove-layout-conversions"; }

  ::llvm::StringRef getDescription() const override { return "remove superfluous layout conversions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURemoveLayoutConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURemoveLayoutConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURemoveLayoutConversionsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUReorderInstructionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReorderInstructionsBase;

  TritonGPUReorderInstructionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReorderInstructionsBase(const TritonGPUReorderInstructionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reorder-instructions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reorder-instructions"; }

  ::llvm::StringRef getDescription() const override { return "Reorder instructions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReorderInstructions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReorderInstructions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReorderInstructionsBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
